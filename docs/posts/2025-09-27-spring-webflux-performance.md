# Webflux 앱이 빌빌댄다? 성능 2300% 올린 삽질기

최신 기술인 Spring Webflux를 야심차게 도입했습니다. 비동기 논블로킹의 마법으로 엄청난 성능을 뽐낼 거라 기대했죠. 하지만 현실은 냉혹했습니다. 고작 `vUser 200명`의 로그인/회원가입 요청에 애플리케이션이 비명을 지르기 시작했습니다. 평균 응답 시간은 10초를 훌쩍 넘겼고, JVM의 CPU 사용률은 100%에 고정되었습니다.

"아니, Webflux라며! 이게 어떻게 된 일이지?"

기대했던 고성능은 온데간데없고, 애플리케이션은 거의 마비 상태였습니다. 대체 어디서부터 잘못된 걸까요? 이 글은 제 Webflux 애플리케이션의 성능을 질식시키던 범인을 찾아나선, 한 편의 추리극이자 삽질의 기록입니다.
![1.png](/2025-09-27-spring-webflux-performance/4.png)

## 1단계: 범죄 현장 분석

<img src="/2025-09-27-spring-webflux-performance/2.png" width="350px"/>

먼저 현장 상황부터 다시 정리해 보죠.

-   **증상**: `vUser 200명` 부하 테스트 시, 평균 응답시간이 **10,000ms**를 돌파.
-   **단서**: JVM CPU 사용률 **100%**. MySQL CPU 사용률도 덩달아 치솟음.

CPU가 100%라는 건, 애플리케이션 내부에서 무언가 미친 듯이 돌아가고 있다는 뜻입니다. 외부 API 호출이나 네트워크 문제라기보다는, 코드 내부에 범인이 숨어있을 확률이 높았죠. 제 머릿속은 복잡해졌습니다. "대체 어디가 문제일까? DB 커넥션? 아니면 예상치 못한 연산?"

가장 유력한 용의선상에 오른 것은 두 가지였습니다.

1.  DB와 통신하는 과정
2.  로그인/회원가입 로직의 특정 연산

저는 이 두 가지를 중심으로 탐문을 시작했습니다.

## 2단계: 첫 번째 용의자 - R2DBC 커넥션

"가장 기본적인 것부터 확인하자."

저는 DB와 관련된 부분을 먼저 찔러보기로 했습니다. Webflux 환경에서는 R2DBC를 사용해 DB와 비동기로 통신하죠. 혹시 여기서 병목이 생기는 건 아닐까요?

**가설**: 요청이 몰릴 때마다 DB 커넥션을 새로 맺느라 리소스를 낭비하고 있다.

이 가설을 검증하기 위해, 아주 단순한 `SELECT 1` 쿼리만 실행하는 테스트 엔드포인트를 만들고 부하를 가했습니다. 만약 이 간단한 쿼리조차 느리다면, 문제는 쿼리가 아니라 DB에 연결하는 과정 그 자체일 겁니다.

결과는 예상대로였습니다. 응답 시간은 **1000ms**를 훌쩍 넘겼습니다. 범인의 윤곽이 드러나는 순간이었죠.

**원인**: R2DBC는 기본적으로 **커넥션 풀(Connection Pool)을 사용하지 않습니다.** 즉, 모든 요청이 자기만의 커넥션을 만들고 버리기를 반복했던 겁니다. 마치 식당에 손님이 올 때마다 일회용 접시를 새로 만들고 버리는 것과 같았죠. 엄청난 낭비였습니다.

**해결책**: 다행히 해결은 간단했습니다. `application.yml` 파일에 몇 줄만 추가해 커넥션 풀을 활성화하면 됩니다.

```yaml
spring:
    r2dbc:
        url: r2dbc:mysql://mysql:3306/testdb
        username: root
        password: root
        pool:
            enabled: true
            initial-size: 5
            max-size: 100
            max-idle-time: 30s
            validation-query: SELECT 1
```

커넥션 풀을 적용하자, 단순 SELECT 테스트는 눈에 띄게 빨라졌습니다. "드디어 해결했나!" 싶었죠. 하지만 로그인/회원가입 전체 로직에 다시 부하를 주자, 성능은 여전히 만족스럽지 않았습니다. CPU 사용률도 여전히 높았고요. 1차 용의자는 잡았지만, 진짜 범인은 따로 있었던 겁니다.

## 3단계: 두 번째 용의자 - CPU를 잡아먹는 암호화 로직

"DB 커넥션이 문제가 아니라면, 이제 남은 건 애플리케이션 로직이다."

로그인/회원가입 과정에서 CPU를 많이 쓸 만한 작업이 뭐가 있을까요? DB에서 데이터를 읽어오는 건 I/O 작업이고, JWT 토큰을 만드는 건 비교적 가벼운 작업입니다. 제 눈에 들어온 단 하나의 용의자는 바로 **비밀번호 암호화**였습니다.

저희는 `Bcrypt` 알고리즘을 사용하고 있었는데, 이 알고리즘은 의도적으로 CPU를 많이 사용하도록 설계되었습니다. 해커가 무차별 대입 공격(Brute-force attack)을 시도하기 어렵게 만들기 위해서죠. 보안에는 강력하지만, 초당 수백 건의 요청을 처리해야 하는 서버에는 큰 부담이 될 수 있습니다.

| 알고리즘 | 속도      | CPU 부하  | 메모리    | 보안성    | Spring 지원       |
| -------- | --------- | --------- | --------- | --------- | ----------------- |
| Bcrypt   | 느림      | 높음      | 낮음      | 높음      | ✅ 기본 지원      |
| PBKDF2   | 빠름      | 낮음      | 낮음      | 높음      | ✅ 기본 지원      |
| scrypt   | 매우 느림 | 매우 높음 | 매우 높음 | 매우 높음 | ⚠️ 외부 필요      |
| Argon2   | 중간      | 중간~높음 | 조절 가능 | 매우 높음 | ⚠️ 별도 설정 필요 |

Webflux의 비동기 모델 위에서 CPU를 많이 쓰는 `Bcrypt`가 돌아가니, 이벤트 루프가 막히면서 전체 시스템이 느려지는 병목 현상이 발생한 겁니다. 고속도로 한가운데 덤프트럭이 서 있는 꼴이었죠.

**해결책**: 보안 수준은 비슷하게 유지하면서도 CPU 부담이 덜한 `PBKDF2`로 암호화 알고리즘을 교체하기로 결정했습니다. Spring Security에서 기본으로 지원하기 때문에 변경도 간단했습니다.

## 최종 결과: 범인 검거, 그리고 2300%의 성능 향상

두 가지 개선 작업을 마친 후, 저는 떨리는 마음으로 다시 부하 테스트를 실행했습니다. 결과는 그야말로 드라마틱했습니다.

**개선 전 (Bcrypt)**
![4.png](/2025-09-27-spring-webflux-performance/4.png)

**개선 후 (PBKDF2 + R2DBC Pool)**
![5.png](/2025-09-27-spring-webflux-performance/4.png)

**초당 요청 처리량(RPS)은 7.5에서 179.8로, 무려 23배(2300%)나 증가했습니다.**

| **지표**   | Median (ms) | 95%ile (ms) | 99%ile (ms) | Average (ms) | Min (ms) | Max (ms) |
| ---------- | ----------- | ----------- | ----------- | ------------ | -------- | -------- |
| **Bcrypt** | 11000       | 15000       | 20000       | 10549.23     | 257      | 22430    |
| **PBKDF2** | 240         | 910         | 1500        | 332.09       | 6        | 2722     |

**평균 응답 시간은 10,549ms에서 332ms로, 96.8%나 감소했습니다.** 10초 넘게 기다려야 했던 작업이 0.3초 만에 끝나는 기적을 목격한 겁니다.

## 결론: 이번 삽질을 통해 얻은 교훈

이번 성능 병목 현상의 범인은 결국 두 명으로 밝혀졌습니다.

1.  **R2DBC 커넥션 풀의 부재**: DB와 연결하는 과정에서 불필요한 리소스를 낭비.
2.  **CPU 부하가 큰 Bcrypt 암호화**: 비동기 모델의 발목을 잡는 CPU-bound 작업.

이 경험을 통해 두 가지 중요한 교훈을 얻었습니다.

첫째, **Webflux 같은 비동기 프레임워크가 모든 것을 해결해주진 않는다.** 특히 CPU를 많이 사용하는 작업은 비동기 환경에서도 여전히 병목 지점이 될 수 있다는 사실을 명심해야 합니다.

둘째, **"기본 설정(Default)"을 맹신하지 말자.** R2DBC에 커넥션 풀이 기본으로 적용되어 있을 거라 막연히 생각했던 것이 화근이었습니다. 항상 사용하는 기술의 특성과 기본 설정을 꼼꼼히 확인하는 습관을 들여야겠습니다.

혹시 저처럼 Webflux의 성능 문제로 고민하는 분이 있다면, 이 삽질기가 작은 힌트가 되길 바랍니다.
