<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Scheduler와 Message Queue를 이용한 레거시 데이터 자동 아카이빙 시스템 구축 | Polyglot-K의 블로그</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css">
    <meta name="description" content="다양한 도전을 즐기는 개발자 Polyglot-K의 블로그입니다.">
    
    <link rel="preload" href="/assets/css/0.styles.6efed9ee.css" as="style"><link rel="preload" href="/assets/js/app.4c9cb557.js" as="script"><link rel="preload" href="/assets/js/2.f7eb169b.js" as="script"><link rel="preload" href="/assets/js/1.bae06eea.js" as="script"><link rel="preload" href="/assets/js/27.3b05e789.js" as="script"><link rel="prefetch" href="/assets/js/10.a8ed9aac.js"><link rel="prefetch" href="/assets/js/11.56e5a865.js"><link rel="prefetch" href="/assets/js/12.8e76f9af.js"><link rel="prefetch" href="/assets/js/13.b66fe074.js"><link rel="prefetch" href="/assets/js/14.4cf20308.js"><link rel="prefetch" href="/assets/js/15.18ef8915.js"><link rel="prefetch" href="/assets/js/16.c2529bc5.js"><link rel="prefetch" href="/assets/js/17.46fff286.js"><link rel="prefetch" href="/assets/js/18.4ea92fd9.js"><link rel="prefetch" href="/assets/js/19.34738524.js"><link rel="prefetch" href="/assets/js/20.c887495e.js"><link rel="prefetch" href="/assets/js/21.64a0c85e.js"><link rel="prefetch" href="/assets/js/22.aa8d2bb9.js"><link rel="prefetch" href="/assets/js/23.a05ca660.js"><link rel="prefetch" href="/assets/js/24.06019492.js"><link rel="prefetch" href="/assets/js/25.d19adc15.js"><link rel="prefetch" href="/assets/js/26.eb01e83e.js"><link rel="prefetch" href="/assets/js/3.8c9b5f96.js"><link rel="prefetch" href="/assets/js/4.d28c46f7.js"><link rel="prefetch" href="/assets/js/5.42da3f61.js"><link rel="prefetch" href="/assets/js/6.222dbcbc.js"><link rel="prefetch" href="/assets/js/7.51e9e0b3.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.663d6e13.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6efed9ee.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Polyglot-K의 블로그</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/posts/2025-08-25-spring-webflux-performance.html" class="nav-link">
  Posts
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/posts/2025-08-25-spring-webflux-performance.html" class="nav-link">
  Posts
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>게시물 목록</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/posts/2025-08-25-spring-webflux-performance.html" class="sidebar-link">Spring Webflux 애플리케이션 성능 병목 분석 및 38배 개선기</a></li><li><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html" aria-current="page" class="active sidebar-link">Scheduler와 Message Queue를 이용한 레거시 데이터 자동 아카이빙 시스템 구축</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html#_1-문제-정의-영구-상태가-된-임시-데이터" class="sidebar-link">1. 문제 정의: 영구 상태가 된 임시 데이터</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html#_2-초기-해결책의-한계-수동-쿼리-실행" class="sidebar-link">2. 초기 해결책의 한계: 수동 쿼리 실행</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html#_3-아키텍처-설계-scheduler와-message-queue의-조합" class="sidebar-link">3. 아키텍처 설계: Scheduler와 Message Queue의 조합</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html#_4-핵심-로직-구현-pseudo-code" class="sidebar-link">4. 핵심 로직 구현 (Pseudo-code)</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html#_5-도입-결과-및-교훈" class="sidebar-link">5. 도입 결과 및 교훈</a></li></ul></li><li><a href="/posts/2025-08-05-valkey-concurrency-issue.html" class="sidebar-link">Valkey(Redis) Lua 스크립트를 이용한 분산 환경의 동시성 문제 해결</a></li><li><a href="/posts/2025-07-20-ice-breaking-platform.html" class="sidebar-link">Spring Boot와 Redis로 분산 실시간 상태 머신 구현하기</a></li><li><a href="/posts/2025-07-15-text-based-real-time-streaming-virtual-interview.html" class="sidebar-link">[Technical Deep Dive] Spring WebFlux와 Redis로 구축한 LLM 스트리밍 파이프라인 여정기</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="scheduler와-message-queue를-이용한-레거시-데이터-자동-아카이빙-시스템-구축"><a href="#scheduler와-message-queue를-이용한-레거시-데이터-자동-아카이빙-시스템-구축" class="header-anchor">#</a> Scheduler와 Message Queue를 이용한 레거시 데이터 자동 아카이빙 시스템 구축</h1> <p>운영 서비스에서 <code>PENDING</code>이나 <code>FAILED</code>와 같이 처리가 완료되지 않은 상태의 데이터가 계속 누적되는 것은 잠재적인 성능 저하와 관리 비용 증가를 유발하는 흔한 문제입니다. 이러한 레거시 데이터는 시간이 지나며 그 양이 불어나고, 결국 데이터베이스의 성능에 직접적인 악영향을 미칠 수 있습니다.</p> <p>이 글에서는 주기적으로 작업을 실행하는 **스케줄러(Scheduler)**와 비동기 처리를 위한 **메시지 큐(Message Queue)**를 조합하여, 운영 DB에 부하를 최소화하면서 레거시 데이터를 안정적으로 자동 아카이빙하는 시스템을 설계하고 구축한 경험을 공유합니다.</p> <h2 id="_1-문제-정의-영구-상태가-된-임시-데이터"><a href="#_1-문제-정의-영구-상태가-된-임시-데이터" class="header-anchor">#</a> 1. 문제 정의: 영구 상태가 된 임시 데이터</h2> <p>시스템 로직상, 특정 데이터는 일시적으로 <code>PENDING</code> 또는 <code>FAILED</code> 상태에 머물다가 후속 프로세스에 의해 <code>COMPLETE</code>로 변경되어야 합니다. 하지만 간헐적인 네트워크 오류나 예상치 못한 예외 케이스로 인해, 일부 데이터가 영구적으로 <code>PENDING</code> 또는 <code>FAILED</code> 상태로 남게 되는 문제가 발생했습니다.</p> <ul><li><strong>현상</strong>: 특정 상태(<code>PENDING</code>, <code>FAILED</code>)의 데이터가 시간이 지나도 변경되지 않고 계속 누적됨.</li> <li><strong>영향</strong>:
<ol><li><strong>DB 성능 저하</strong>: 불필요한 데이터가 인덱스 크기를 비대화시키고, 관련 테이블 조회 쿼리의 성능을 저하시켰습니다.</li> <li><strong>스토리지 비용 증가</strong>: 수백만 건의 불필요한 데이터가 상당한 양의 디스크 공간을 차지하여 비용을 증가시켰습니다.</li> <li><strong>운영 복잡성 증가</strong>: 데이터 분석, 마이그레이션 등 운영 작업 시 불필요한 데이터를 매번 필터링해야 하는 번거로움이 있었습니다.</li></ol></li></ul> <h2 id="_2-초기-해결책의-한계-수동-쿼리-실행"><a href="#_2-초기-해결책의-한계-수동-쿼리-실행" class="header-anchor">#</a> 2. 초기 해결책의 한계: 수동 쿼리 실행</h2> <p>가장 먼저 시도한 방법은 특정 기간(예: 30일)이 지난 <code>PENDING</code> 또는 <code>FAILED</code> 데이터를 주기적으로 찾아 수동 <code>DELETE</code> 쿼리를 실행하는 것이었습니다. 하지만 이 방식은 다음과 같은 명확한 한계를 가졌습니다.</p> <ul><li><strong>휴먼 에러의 위험</strong>: <code>DELETE</code> 쿼리는 항상 데이터 유실의 위험을 내포합니다. <code>WHERE</code> 조건의 작은 실수가 심각한 운영 장애로 이어질 수 있습니다.</li> <li><strong>비생산적인 운영 리소스</strong>: 누군가는 이 작업을 잊지 않고 주기적으로 실행해야 했으며, 이는 비생산적인 리소스 낭비였습니다.</li> <li><strong>운영 DB 부하</strong>: 대량의 데이터를 삭제하는 <code>DELETE</code> 작업은 그 자체로 운영 DB에 상당한 부하를 주어 다른 트랜잭션에 영향을 줄 수 있습니다.</li></ul> <p>결국, 사람의 개입 없이 안정적으로 동작하는 자동화 시스템의 필요성이 대두되었습니다.</p> <h2 id="_3-아키텍처-설계-scheduler와-message-queue의-조합"><a href="#_3-아키텍처-설계-scheduler와-message-queue의-조합" class="header-anchor">#</a> 3. 아키텍처 설계: Scheduler와 Message Queue의 조합</h2> <p>새로운 시스템의 핵심 목표는 <strong>&quot;운영 DB 부하 최소화, 안정성, 완전 자동화&quot;</strong> 였습니다. 이를 위해 <strong>Scheduler</strong>와 **Message Queue(MQ)**를 조합한 비동기 처리 아키텍처를 채택했습니다.</p> <p><strong>처리 흐름:</strong></p> <ol><li><strong>Scheduler</strong>: 트래픽이 가장 적은 시간대(예: 매일 새벽 3시)에 주기적으로 실행됩니다.</li> <li><strong>대상 선정</strong>: 아카이빙 대상이 되는 데이터의 <code>ID</code> 목록만 조회합니다. 전체 데이터를 조회하지 않음으로써 DB 부하를 최소화합니다.</li> <li><strong>메시지 발행</strong>: 조회된 <code>ID</code>를 개별 메시지로 만들어 MQ에 발행(Publish)합니다.</li> <li><strong>Worker (Consumer)</strong>: MQ를 구독(Subscribe)하는 별도의 워커(Worker) 프로세스가 메시지를 순차적으로 수신하여 데이터 처리 작업을 수행합니다.</li> <li><strong>아카이빙 및 삭제</strong>: 워커는 <code>ID</code>를 이용해 데이터를 조회한 후, 별도의 아카이빙 스토리지(Cold Storage, S3 등)에 백업하고, 원본 DB에서 해당 데이터를 삭제합니다.</li></ol> <p><strong>아키텍처의 핵심 장점:</strong></p> <ul><li><strong>관심사 분리 (SoC)</strong>: 데이터 '선별' 로직(Scheduler)과 실제 '처리' 로직(Worker)이 명확하게 분리되어 유지보수성이 향상됩니다.</li> <li><strong>부하 분산</strong>: 실제 데이터 삭제 작업이 비동기적으로 워커에서 처리되므로, 스케줄러 실행 시점이나 메인 애플리케이션에 거의 영향을 주지 않습니다.</li> <li><strong>높은 안정성 및 확장성</strong>: 워커의 처리 실패 시, MQ의 재시도(Retry) 또는 데드 레터 큐(Dead-letter Queue) 기능을 통해 데이터 유실 없이 안정적인 처리가 가능합니다. 또한 처리량이 많아지면 워커의 수만 늘려 간단히 확장할 수 있습니다.</li></ul> <h2 id="_4-핵심-로직-구현-pseudo-code"><a href="#_4-핵심-로직-구현-pseudo-code" class="header-anchor">#</a> 4. 핵심 로직 구현 (Pseudo-code)</h2> <p>구현의 핵심은 각 컴포넌트의 역할을 명확히 하는 것입니다.</p> <p><strong>1. Scheduler: 아카이빙 대상 선정 및 메시지 발행</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// Spring Framework 기준 예시</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LegacyDataArchivingScheduler</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>cron <span class="token operator">=</span> <span class="token string">&quot;0 0 3 * * ?&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 매일 새벽 3시 실행</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduleArchiving</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1. 30일 이상 경과된 특정 상태의 데이터 ID 목록을 조회</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> targetStatuses <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">&quot;PENDING&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;FAILED&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> targetIds <span class="token operator">=</span> dataRepository<span class="token punctuation">.</span><span class="token function">findIdsByStatusesAndDate</span><span class="token punctuation">(</span>targetStatuses<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 2. 각 ID를 MQ에 아카이빙 작업 메시지로 발행</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Long</span> id <span class="token operator">:</span> targetIds<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            messageQueueProducer<span class="token punctuation">.</span><span class="token function">publishArchivingTask</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>2. Worker: 메시지 수신 및 데이터 처리</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// RabbitMQ 기준 예시</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArchivingWorker</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">&quot;archiving-task-queue&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleArchivingTask</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 1. ID로 데이터 조회</span>
            <span class="token class-name">DataObject</span> data <span class="token operator">=</span> dataRepository<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">&quot;Data with id {} already processed or does not exist.&quot;</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 2. 아카이빙 스토리지에 백업</span>
            archiveStorage<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 3. 원본 DB에서 삭제</span>
            dataRepository<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 4. 실패 시, 로그를 남기고 MQ의 재시도/DLQ 정책에 따라 처리되도록 예외를 다시 던짐</span>
            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Failed to archive data with id: {}. Error: {}&quot;</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AmqpRejectAndDontRequeueException</span><span class="token punctuation">(</span><span class="token string">&quot;Archiving failed&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_5-도입-결과-및-교훈"><a href="#_5-도입-결과-및-교훈" class="header-anchor">#</a> 5. 도입 결과 및 교훈</h2> <p>자동 아카이빙 시스템 도입 후, 다음과 같은 정량적/정성적 효과를 얻었습니다.</p> <ul><li><strong>DB 스토리지 사용량 안정화</strong>: 불필요한 데이터로 인한 스토리지 사용량의 지속적인 증가 문제가 해결되었습니다.</li> <li><strong>쿼리 성능 향상</strong>: 관련 테이블의 인덱스 크기가 최적화되어, 주요 조회 쿼리의 성능이 평균 15% 향상되었습니다.</li> <li><strong>운영 효율성 증대</strong>: 데이터 관리에 투입되던 수동 작업을 완전히 제거하여, 개발팀이 핵심 비즈니스 로직 개발에 더 집중할 수 있게 되었습니다.</li></ul> <p>이번 프로젝트를 통해 얻은 교훈은 다음과 같습니다.</p> <ol><li><strong>데이터는 라이프사이클 관리가 필요하다</strong>: 모든 데이터는 생성, 사용, 보관, 폐기의 라이프사이클을 가집니다. 일시적인 상태를 가지는 데이터는 반드시 최종 상태를 보장하거나, 주기적으로 정리하는 정책 및 시스템을 초기에 설계하는 것이 중요합니다.</li> <li><strong>비동기 아키텍처의 적극적인 활용</strong>: 대량의 데이터를 주기적으로 처리해야 하는 백그라운드 작업의 경우, 동기 방식보다는 스케줄러와 MQ를 이용한 비동기 아키텍처가 시스템 안정성과 확장성 측면에서 훨씬 유리합니다.</li></ol> <div class="comment-section" data-v-36cf6e80><div id="giscus-container" data-v-36cf6e80></div></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/posts/2025-08-25-spring-webflux-performance.html" class="prev">
        Spring Webflux 애플리케이션 성능 병목 분석 및 38배 개선기
      </a></span> <span class="next"><a href="/posts/2025-08-05-valkey-concurrency-issue.html">
        Valkey(Redis) Lua 스크립트를 이용한 분산 환경의 동시성 문제 해결
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.4c9cb557.js" defer></script><script src="/assets/js/2.f7eb169b.js" defer></script><script src="/assets/js/1.bae06eea.js" defer></script><script src="/assets/js/27.3b05e789.js" defer></script>
  </body>
</html>
