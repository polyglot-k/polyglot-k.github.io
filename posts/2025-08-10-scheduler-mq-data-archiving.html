<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>아웃박스 패턴을 통한 중간 상태 데이터 관리와 복원 가능한 배치 설계 | Polyglot-K의 블로그</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css">
    <meta name="description" content="다양한 도전을 즐기는 개발자 Polyglot-K의 블로그입니다.">
    
    <link rel="preload" href="/assets/css/0.styles.6efed9ee.css" as="style"><link rel="preload" href="/assets/js/app.3e0c7978.js" as="script"><link rel="preload" href="/assets/js/2.e2e96b39.js" as="script"><link rel="preload" href="/assets/js/1.49846db0.js" as="script"><link rel="preload" href="/assets/js/27.017d7e2a.js" as="script"><link rel="prefetch" href="/assets/js/10.1e3fe773.js"><link rel="prefetch" href="/assets/js/11.56e5a865.js"><link rel="prefetch" href="/assets/js/12.1aa3b0c3.js"><link rel="prefetch" href="/assets/js/13.1dd11157.js"><link rel="prefetch" href="/assets/js/14.0122fd01.js"><link rel="prefetch" href="/assets/js/15.18ef8915.js"><link rel="prefetch" href="/assets/js/16.98147816.js"><link rel="prefetch" href="/assets/js/17.46fff286.js"><link rel="prefetch" href="/assets/js/18.a9838e2e.js"><link rel="prefetch" href="/assets/js/19.34738524.js"><link rel="prefetch" href="/assets/js/20.27ef86b3.js"><link rel="prefetch" href="/assets/js/21.c7b8d009.js"><link rel="prefetch" href="/assets/js/22.f84154f0.js"><link rel="prefetch" href="/assets/js/23.fbc1d3ff.js"><link rel="prefetch" href="/assets/js/24.c58c220f.js"><link rel="prefetch" href="/assets/js/25.8c8a0afd.js"><link rel="prefetch" href="/assets/js/26.e0bcc60b.js"><link rel="prefetch" href="/assets/js/3.75064c1e.js"><link rel="prefetch" href="/assets/js/4.2afe5cdc.js"><link rel="prefetch" href="/assets/js/5.a37b361e.js"><link rel="prefetch" href="/assets/js/6.c34bda13.js"><link rel="prefetch" href="/assets/js/7.b04f2031.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.6fed1ae2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6efed9ee.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Polyglot-K의 블로그</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/posts/2025-08-25-spring-webflux-performance.html" class="nav-link">
  Posts
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/posts/2025-08-25-spring-webflux-performance.html" class="nav-link">
  Posts
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>게시물 목록</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/posts/2025-08-25-spring-webflux-performance.html" class="sidebar-link">Spring Webflux 애플리케이션 성능 병목 분석 및 38배 개선기</a></li><li><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html" aria-current="page" class="active sidebar-link">아웃박스 패턴을 통한 중간 상태 데이터 관리와 복원 가능한 배치 설계</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html#_1️⃣-문제-인식-고아-orphan-데이터의-누적" class="sidebar-link">1️⃣ 문제 인식 — 고아(Orphan) 데이터의 누적</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html#_2️⃣-해결-방향-상태-기반-outbox-이벤트-관리" class="sidebar-link">2️⃣ 해결 방향 — 상태 기반 Outbox 이벤트 관리</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html#주요-설계-포인트" class="sidebar-link">주요 설계 포인트</a></li></ul></li><li class="sidebar-sub-header"><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html#_3️⃣-outbox-→-mq-흐름-설계" class="sidebar-link">3️⃣ Outbox → MQ 흐름 설계</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html#선택-이유" class="sidebar-link">선택 이유</a></li></ul></li><li class="sidebar-sub-header"><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html#_4️⃣-batch-listener에서의-재개-resume-설계" class="sidebar-link">4️⃣ Batch Listener에서의 재개(Resume) 설계</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html#_5️⃣-상태-기반-resume-전략-ready-→-processing-→-done" class="sidebar-link">5️⃣ 상태 기반 Resume 전략 (READY → PROCESSING → DONE)</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html#_6️⃣-확장-고려-단일-인스턴스-→-다중-인스턴스" class="sidebar-link">6️⃣ 확장 고려 — 단일 인스턴스 → 다중 인스턴스</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html#_7️⃣-회고" class="sidebar-link">7️⃣ 회고</a></li></ul></li><li><a href="/posts/2025-08-05-valkey-concurrency-issue.html" class="sidebar-link">Redis Lua 스크립트를 활용한 동시성 제어와 좌석 선점 로직 개선기</a></li><li><a href="/posts/2025-07-20-ice-breaking-platform.html" class="sidebar-link">Redis Pub/Sub 으로 분산 실시간 상태 머신 구현하기</a></li><li><a href="/posts/2025-07-15-text-based-real-time-streaming-virtual-interview.html" class="sidebar-link">Spring WebFlux와 Redis로 구축한 LLM 스트리밍 파이프라인</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="아웃박스-패턴을-통한-중간-상태-데이터-관리와-복원-가능한-배치-설계"><a href="#아웃박스-패턴을-통한-중간-상태-데이터-관리와-복원-가능한-배치-설계" class="header-anchor">#</a> 아웃박스 패턴을 통한 중간 상태 데이터 관리와 복원 가능한 배치 설계</h1> <p>모의 수능 신청 플랫폼을 운영하면서, “신청을 완료하지 않은 사용자”로 인해 <strong>중간 상태의 데이터가 지속적으로 남는 문제</strong>를 겪었다.
특히 결제 페이지까지 갔다가 이탈한 사용자나, 네트워크 오류로 인해 결제가 실패한 케이스에서 <code>application</code> 테이블에 <strong>PENDING</strong> 혹은 <strong>FAILED</strong> 상태의 데이터가 그대로 잔류했다.
이 문제는 시간이 지날수록 누적되었고, 단순히 데이터 정리 문제를 넘어 <strong>시스템 정합성</strong>과 <strong>좌석 수 동기화</strong>에도 영향을 주었다.</p> <h2 id="_1️⃣-문제-인식-고아-orphan-데이터의-누적"><a href="#_1️⃣-문제-인식-고아-orphan-데이터의-누적" class="header-anchor">#</a> 1️⃣ 문제 인식 — 고아(Orphan) 데이터의 누적</h2> <p>처음에는 단순히 “나중에 쿼리로 정리하면 되지 않을까?”라고 생각했다.
하지만 실제 운영 환경에서는 이 문제를 무시할 수 없었다.</p> <ul><li>신청만 하고 결제하지 않은 사용자 → <code>PENDING</code> 상태로 남음</li> <li>결제 도중 오류가 발생한 사용자 → <code>FAILED</code> 상태로 남음</li> <li>이미 좌석은 Redis Lua를 통해 선점되어 있었음</li></ul> <p>즉, 결제 실패나 이탈로 인해 <strong>DB는 실패 상태를 가지고 있지만 Redis에는 여전히 좌석이 점유된 상태</strong>가 되는 불일치가 발생했다.
이 불일치는 Outbox 기반의 보상 트랜잭션 설계로 해결할 수 있었다.</p> <h2 id="_2️⃣-해결-방향-상태-기반-outbox-이벤트-관리"><a href="#_2️⃣-해결-방향-상태-기반-outbox-이벤트-관리" class="header-anchor">#</a> 2️⃣ 해결 방향 — 상태 기반 Outbox 이벤트 관리</h2> <p>이 문제를 해결하기 위해, <strong>Outbox 패턴을 도입하여 중간 상태를 이벤트로 관리</strong>하기로 했다.
핵심 아이디어는 “상태 변경을 단순히 DB에만 반영하지 않고, Outbox에 기록하여 비동기로 후속 처리”하는 것이다.</p> <h3 id="주요-설계-포인트"><a href="#주요-설계-포인트" class="header-anchor">#</a> 주요 설계 포인트</h3> <ul><li><p><strong>PENDING → FAILED → CLEANED</strong></p> <ul><li>결제 실패 시 <code>application</code> 상태를 <code>FAILED</code>로 변경하고,
동시에 Outbox에 “FAIL_EVENT”를 생성한다.</li></ul></li> <li><p><strong>장기 PENDING 처리</strong></p> <ul><li>신청만 하고 일정 시간 이상 진행이 없는 경우,
스케줄러가 <code>PENDING</code> 데이터를 조회하여 Outbox에 “CLEAN_PENDING_EVENT”를 추가한다.</li></ul></li> <li><p><strong>보상 로직 연동</strong></p> <ul><li>Lua 스크립트를 통해 Redis의 좌석 정보를 동기화하고,
DB와 Redis의 상태를 일치시킨다.</li></ul></li></ul> <p>이 구조 덕분에 데이터 정리 로직이 트랜잭션 내부에 포함되지 않고,
Outbox를 통해 안전하게 후처리될 수 있었다.</p> <h2 id="_3️⃣-outbox-→-mq-흐름-설계"><a href="#_3️⃣-outbox-→-mq-흐름-설계" class="header-anchor">#</a> 3️⃣ Outbox → MQ 흐름 설계</h2> <p>Outbox에 적재된 이벤트는 Poller가 주기적으로 조회하고,
처리할 이벤트를 MQ로 전달한다.
이때 여러 후보 중에서 <strong>RabbitMQ</strong>를 선택했다.</p> <h3 id="선택-이유"><a href="#선택-이유" class="header-anchor">#</a> 선택 이유</h3> <ul><li><strong>DLQ(Dead Letter Queue)</strong> 기능이 내장되어 있어,
실패한 이벤트를 따로 보관하고 운영자가 직접 모니터링 가능</li> <li><strong>Persistent Queue</strong> 설정을 통해 이벤트 유실 위험을 최소화</li> <li><strong>Batch 처리</strong> 및 <strong>재시도(backoff)</strong> 전략을 유연하게 조정 가능</li></ul> <p>결국 Outbox → RabbitMQ → Listener 구조로 안정적인 이벤트 흐름이 만들어졌다.</p> <h2 id="_4️⃣-batch-listener에서의-재개-resume-설계"><a href="#_4️⃣-batch-listener에서의-재개-resume-설계" class="header-anchor">#</a> 4️⃣ Batch Listener에서의 재개(Resume) 설계</h2> <p>이벤트를 수신한 RabbitMQ Listener는
관련된 <code>application</code> 데이터를 Batch 단위로 가져와 JSON 스냅샷을 생성하고,
이를 임시 보존 테이블에 저장한 뒤 삭제한다.</p> <p>그러나 여기서 새로운 문제가 발생했다.
<strong>“Batch 처리 중간에 실패하면 어디서부터 다시 시작할 것인가?”</strong></p> <p>초기 구현에서는 단순히 예외 발생 시 전체 배치를 롤백시켰다.
하지만 이 방식은 이미 처리된 데이터까지 재처리하게 되어 비효율적이었다.</p> <p>이를 해결하기 위해, <strong>Outbox 이벤트 상태를 명시적으로 관리하는 Resume 전략</strong>을 도입했다.</p> <h2 id="_5️⃣-상태-기반-resume-전략-ready-→-processing-→-done"><a href="#_5️⃣-상태-기반-resume-전략-ready-→-processing-→-done" class="header-anchor">#</a> 5️⃣ 상태 기반 Resume 전략 (READY → PROCESSING → DONE)</h2> <p>각 Outbox 이벤트는 세 가지 상태를 가진다.</p> <table><thead><tr><th>상태</th> <th>의미</th></tr></thead> <tbody><tr><td><strong>READY</strong></td> <td>아직 처리되지 않은 이벤트</td></tr> <tr><td><strong>PROCESSING</strong></td> <td>현재 배치 처리 중</td></tr> <tr><td><strong>DONE</strong></td> <td>성공적으로 완료된 이벤트</td></tr></tbody></table> <p>배치 Listener는 Outbox에서 <code>READY</code> 상태의 이벤트만 가져와 처리한다.
처리 도중 예외가 발생하면 해당 이벤트는 <code>PROCESSING</code> 상태로 남게 된다.
이후 Poller가 다시 실행될 때,
**“DONE이 아닌 이벤트”**부터 재개하도록 설계했다.</p> <p>이 구조는 단순하지만 강력하다.
시스템이 중간에 중단되더라도, Outbox의 상태 정보 덕분에
어디서부터 다시 시작해야 하는지 명확히 알 수 있다.</p> <h2 id="_6️⃣-확장-고려-단일-인스턴스-→-다중-인스턴스"><a href="#_6️⃣-확장-고려-단일-인스턴스-→-다중-인스턴스" class="header-anchor">#</a> 6️⃣ 확장 고려 — 단일 인스턴스 → 다중 인스턴스</h2> <p>현재는 단일 인스턴스 기반이기 때문에,
별도의 분산 조정 없이도 안전하게 Resume가 가능하다.
하지만 서비스가 확장되어 여러 Consumer 인스턴스가 동작하게 되면,
중복 처리를 방지하기 위해 <strong>분산락(distributed lock)</strong> 이 필요하다.</p> <p>Redis 기반의 분산락 또는 RabbitMQ의 Consumer tag를 이용해
“하나의 이벤트는 오직 하나의 Consumer만 처리하도록” 설계할 예정이다.</p> <h2 id="_7️⃣-회고"><a href="#_7️⃣-회고" class="header-anchor">#</a> 7️⃣ 회고</h2> <p>이 경험을 통해 배운 점은 명확하다.
<strong>이벤트를 삭제하기보다, 상태를 명시적으로 관리하라.</strong></p> <p>Outbox 패턴을 단순히 “비동기 트랜잭션 전달용”으로만 사용하면
중간 상태 복구나 재시작(resume)이 어렵다.
하지만 Outbox의 상태를 세분화하고, 이를 기반으로 Resume 가능한 설계를 도입하면
예상치 못한 장애 상황에서도 데이터를 안전하게 복원할 수 있다.</p> <div class="comment-section" data-v-36cf6e80><div id="giscus-container" data-v-36cf6e80></div></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/posts/2025-08-25-spring-webflux-performance.html" class="prev">
        Spring Webflux 애플리케이션 성능 병목 분석 및 38배 개선기
      </a></span> <span class="next"><a href="/posts/2025-08-05-valkey-concurrency-issue.html">
        Redis Lua 스크립트를 활용한 동시성 제어와 좌석 선점 로직 개선기
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3e0c7978.js" defer></script><script src="/assets/js/2.e2e96b39.js" defer></script><script src="/assets/js/1.49846db0.js" defer></script><script src="/assets/js/27.017d7e2a.js" defer></script>
  </body>
</html>
