<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Valkey(Redis) Lua 스크립트를 이용한 분산 환경의 동시성 문제 해결 | Polyglot-K의 블로그</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css">
    <meta name="description" content="다양한 도전을 즐기는 개발자 Polyglot-K의 블로그입니다.">
    
    <link rel="preload" href="/assets/css/0.styles.6efed9ee.css" as="style"><link rel="preload" href="/assets/js/app.4c9cb557.js" as="script"><link rel="preload" href="/assets/js/2.f7eb169b.js" as="script"><link rel="preload" href="/assets/js/1.bae06eea.js" as="script"><link rel="preload" href="/assets/js/26.eb01e83e.js" as="script"><link rel="prefetch" href="/assets/js/10.a8ed9aac.js"><link rel="prefetch" href="/assets/js/11.56e5a865.js"><link rel="prefetch" href="/assets/js/12.8e76f9af.js"><link rel="prefetch" href="/assets/js/13.b66fe074.js"><link rel="prefetch" href="/assets/js/14.4cf20308.js"><link rel="prefetch" href="/assets/js/15.18ef8915.js"><link rel="prefetch" href="/assets/js/16.c2529bc5.js"><link rel="prefetch" href="/assets/js/17.46fff286.js"><link rel="prefetch" href="/assets/js/18.4ea92fd9.js"><link rel="prefetch" href="/assets/js/19.34738524.js"><link rel="prefetch" href="/assets/js/20.c887495e.js"><link rel="prefetch" href="/assets/js/21.64a0c85e.js"><link rel="prefetch" href="/assets/js/22.aa8d2bb9.js"><link rel="prefetch" href="/assets/js/23.a05ca660.js"><link rel="prefetch" href="/assets/js/24.06019492.js"><link rel="prefetch" href="/assets/js/25.d19adc15.js"><link rel="prefetch" href="/assets/js/27.3b05e789.js"><link rel="prefetch" href="/assets/js/3.8c9b5f96.js"><link rel="prefetch" href="/assets/js/4.d28c46f7.js"><link rel="prefetch" href="/assets/js/5.42da3f61.js"><link rel="prefetch" href="/assets/js/6.222dbcbc.js"><link rel="prefetch" href="/assets/js/7.51e9e0b3.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.663d6e13.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6efed9ee.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Polyglot-K의 블로그</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/posts/2025-08-25-spring-webflux-performance.html" class="nav-link">
  Posts
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/posts/2025-08-25-spring-webflux-performance.html" class="nav-link">
  Posts
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>게시물 목록</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/posts/2025-08-25-spring-webflux-performance.html" class="sidebar-link">Spring Webflux 애플리케이션 성능 병목 분석 및 38배 개선기</a></li><li><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html" class="sidebar-link">Scheduler와 Message Queue를 이용한 레거시 데이터 자동 아카이빙 시스템 구축</a></li><li><a href="/posts/2025-08-05-valkey-concurrency-issue.html" aria-current="page" class="active sidebar-link">Valkey(Redis) Lua 스크립트를 이용한 분산 환경의 동시성 문제 해결</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/posts/2025-08-05-valkey-concurrency-issue.html#_1-문제-상황-동시-요청-시-발생하는-데이터-부정합" class="sidebar-link">1. 문제 상황: 동시 요청 시 발생하는 데이터 부정합</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-05-valkey-concurrency-issue.html#_2-실패한-해결책-watch를-이용한-트랜잭션" class="sidebar-link">2. 실패한 해결책: WATCH를 이용한 트랜잭션</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-05-valkey-concurrency-issue.html#_3-근본적인-해결책-lua-스크립트를-이용한-atomic-연산" class="sidebar-link">3. 근본적인 해결책: Lua 스크립트를 이용한 Atomic 연산</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-05-valkey-concurrency-issue.html#_4-최종-결과-및-교훈" class="sidebar-link">4. 최종 결과 및 교훈</a></li></ul></li><li><a href="/posts/2025-07-20-ice-breaking-platform.html" class="sidebar-link">Spring Boot와 Redis로 분산 실시간 상태 머신 구현하기</a></li><li><a href="/posts/2025-07-15-text-based-real-time-streaming-virtual-interview.html" class="sidebar-link">[Technical Deep Dive] Spring WebFlux와 Redis로 구축한 LLM 스트리밍 파이프라인 여정기</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="valkey-redis-lua-스크립트를-이용한-분산-환경의-동시성-문제-해결"><a href="#valkey-redis-lua-스크립트를-이용한-분산-환경의-동시성-문제-해결" class="header-anchor">#</a> Valkey(Redis) Lua 스크립트를 이용한 분산 환경의 동시성 문제 해결</h1> <p>선착순 이벤트, 수강 신청, 한정 수량 상품 판매 등 여러 사용자가 동시에 한정된 자원을 요청하는 시스템에서는 <strong>동시성 제어</strong>가 매우 중요합니다. 동시성 제어가 제대로 이루어지지 않으면, 재고 이상의 상품이 판매되거나 정원 이상의 인원이 신청되는 등 심각한 데이터 불일치 문제를 야기할 수 있습니다.</p> <p>이 글에서는 인메모리 데이터 저장소 Valkey(Redis)를 이용해 선착순 신청 기능을 구현하는 과정에서 발생한 <strong>동시성 이슈</strong>를 분석하고, <strong>Lua 스크립트</strong>를 활용하여 이 문제를 해결한 과정을 다룹니다.</p> <h2 id="_1-문제-상황-동시-요청-시-발생하는-데이터-부정합"><a href="#_1-문제-상황-동시-요청-시-발생하는-데이터-부정합" class="header-anchor">#</a> 1. 문제 상황: 동시 요청 시 발생하는 데이터 부정합</h2> <p>선착순 50명 정원의 이벤트를 위해, Valkey를 카운터로 사용하는 간단한 신청 로직을 구현했습니다. 하지만 <code>vUser 50명</code>의 동시 요청 테스트에서 약 <strong>20%의 요청이 실패</strong>하고, 간헐적으로 정원 이상의 인원이 신청되는 데이터 부정합 문제까지 발견되었습니다.</p> <p>최초에 구현한 코드는 다음과 같은 <strong>&quot;읽고-수정-쓰기(Read-Modify-Write)&quot;</strong> 패턴의 문제점을 가지고 있었습니다.</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 문제의 코드: Race Condition에 취약한 구조</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token string">&quot;event:1:apply_count&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> limit <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>

    <span class="token comment">// 1. READ: 현재 신청자 수를 가져온다</span>
    <span class="token keyword">int</span> currentCount <span class="token operator">=</span> valkey<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2. MODIFY: 애플리케이션 단에서 50명 미만인지 확인한다</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentCount <span class="token operator">&lt;</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 3. WRITE: 카운트를 1 증가시킨다</span>
        valkey<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>이 코드는 두 개 이상의 스레드가 <code>get()</code>과 <code>increment()</code> 호출 사이에 끼어들 경우 <strong>Race Condition(경쟁 상태)</strong> 에 빠지게 됩니다. 예를 들어, 두 스레드가 동시에 <code>49</code>라는 값을 읽었다면, 두 스레드 모두 조건을 통과하여 카운터를 <code>51</code>까지 증가시키게 됩니다.</p> <h2 id="_2-실패한-해결책-watch를-이용한-트랜잭션"><a href="#_2-실패한-해결책-watch를-이용한-트랜잭션" class="header-anchor">#</a> 2. 실패한 해결책: WATCH를 이용한 트랜잭션</h2> <p>이러한 Race Condition을 해결하기 위해 Valkey의 <code>WATCH</code> 명령어를 이용한 **낙관적 락(Optimistic Lock)**을 도입했습니다. <code>WATCH</code>는 감시하는 키의 값이 트랜잭션 실행 전에 변경되면 해당 트랜잭션을 실패시키는 기능입니다.</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// WATCH를 이용한 트랜잭션 시도</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token string">&quot;event:1:apply_count&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> limit <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>

    valkey<span class="token punctuation">.</span><span class="token function">watch</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1. 카운트 키 감시</span>
    <span class="token keyword">int</span> currentCount <span class="token operator">=</span> valkey<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentCount <span class="token operator">&lt;</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        valkey<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2. 트랜잭션 시작</span>
        valkey<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> valkey<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3. 실행</span>

        <span class="token comment">// result가 null이면 WATCH 키가 변경되어 트랜잭션이 실패했음을 의미</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    valkey<span class="token punctuation">.</span><span class="token function">unwatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 트랜잭션 실패 또는 정원 초과</span>
<span class="token punctuation">}</span>
</code></pre></div><p>데이터 정합성 문제는 해결되었지만, 이것이 바로 <strong>20% 요청 실패의 주된 원인</strong>이었습니다. 동시 요청이 몰리는 <strong>경쟁이 심한(High Contention)</strong> 환경에서는, 단 하나의 트랜잭션만 성공하고 나머지 모든 트랜잭션은 <code>WATCH</code> 키의 변경으로 인해 실패하게 됩니다. 실패한 요청들이 재시도를 반복하면서 시스템의 전반적인 처리량은 오히려 감소했습니다.</p> <h2 id="_3-근본적인-해결책-lua-스크립트를-이용한-atomic-연산"><a href="#_3-근본적인-해결책-lua-스크립트를-이용한-atomic-연산" class="header-anchor">#</a> 3. 근본적인 해결책: Lua 스크립트를 이용한 Atomic 연산</h2> <p>&quot;읽고-수정-쓰기&quot; 연산을 외부의 방해 없이 한 번의 원자적(Atomic) 단위로 실행할 필요가 있었습니다. 해답은 <strong>Valkey 서버 내부에서 직접 로직을 실행</strong>시키는 <strong>Lua 스크립트</strong>였습니다.</p> <p>Valkey(Redis)는 Lua 스크립트 하나가 실행되는 동안 다른 어떤 명령도 처리하지 않으므로, 스크립트 전체의 원자성을 보장합니다. 이를 통해 Race Condition을 근본적으로 해결할 수 있습니다.</p> <p><strong>Lua 스크립트:</strong></p> <div class="language-lua extra-class"><pre class="language-lua"><code><span class="token comment">-- apply_script.lua</span>

<span class="token comment">-- KEYS[1]: 카운터 키</span>
<span class="token keyword">local</span> key <span class="token operator">=</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token comment">-- ARGV[1]: 정원(limit)</span>
<span class="token keyword">local</span> limit <span class="token operator">=</span> <span class="token function">tonumber</span><span class="token punctuation">(</span>ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">-- 현재 카운트를 가져온다 (없으면 0)</span>
<span class="token keyword">local</span> count <span class="token operator">=</span> <span class="token function">tonumber</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">)</span>

<span class="token comment">-- 정원 미만일 경우에만</span>
<span class="token keyword">if</span> count <span class="token operator">&lt;</span> limit <span class="token keyword">then</span>
  <span class="token comment">-- 카운터를 1 증가시키고 성공(1)을 반환</span>
  redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'INCR'</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token number">1</span>
<span class="token keyword">end</span>

<span class="token comment">-- 정원 초과 시 실패(0)를 반환</span>
<span class="token keyword">return</span> <span class="token number">0</span>
</code></pre></div><p>애플리케이션에서는 이 Lua 스크립트를 Valkey 서버로 보내 실행하기만 하면 됩니다. <code>GET</code>, <code>비교</code>, <code>INCR</code> 로직 전체가 서버 내에서 한 번의 아토믹 연산으로 처리됩니다.</p> <h2 id="_4-최종-결과-및-교훈"><a href="#_4-최종-결과-및-교훈" class="header-anchor">#</a> 4. 최종 결과 및 교훈</h2> <p>Lua 스크립트 도입 후, 동일한 부하 테스트에서 다음과 같이 극적인 성능 향상을 확인했습니다.</p> <table><thead><tr><th style="text-align:left;">지표</th> <th style="text-align:left;">Before (WATCH)</th> <th style="text-align:left;">After (Lua Script)</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>동시 사용자</strong></td> <td style="text-align:left;">50</td> <td style="text-align:left;">50</td></tr> <tr><td style="text-align:left;"><strong>성공률</strong></td> <td style="text-align:left;">80%</td> <td style="text-align:left;"><strong>100%</strong></td></tr> <tr><td style="text-align:left;"><strong>실패율</strong></td> <td style="text-align:left;">20%</td> <td style="text-align:left;"><strong>0%</strong></td></tr> <tr><td style="text-align:left;"><strong>처리량 (RPS)</strong></td> <td style="text-align:left;">~85</td> <td style="text-align:left;"><strong>~250 (약 3배 향상)</strong></td></tr></tbody></table> <p>모든 요청이 데이터 정합성을 유지하면서 단 한 건의 실패도 없이 처리되었습니다. 이는 Lua 스크립트를 통해 불필요한 네트워크 왕복과 애플리케이션 단의 재시도 로직을 제거하고, 모든 로직을 서버 내에서 원자적으로 처리한 결과입니다.</p> <p><strong>이번 프로젝트를 통해 얻은 교훈은 다음과 같습니다.</strong></p> <ol><li><strong>분산 환경의 &quot;읽고-수정-쓰기&quot; 패턴을 경계하라</strong>: 이 패턴은 동시성 문제의 주된 원인입니다. 이를 발견했다면 즉시 아토믹 연산으로 대체하는 것을 고려해야 합니다.</li> <li><strong>상황에 맞는 동시성 제어 기법을 선택하라</strong>: 낙관적 락(<code>WATCH</code>)은 경쟁이 적은 환경에서는 유용할 수 있지만, 선착순 이벤트와 같이 경쟁이 매우 심한 환경에서는 오히려 성능 저하를 유발합니다.</li> <li><strong>데이터 저장소의 서버 사이드 기능을 적극 활용하라</strong>: Valkey/Redis의 Lua 스크립트와 같이, 데이터 저장소가 제공하는 서버 사이드 기능을 활용하면 네트워크 비용을 줄이고, Race Condition을 우아하고 효과적으로 해결할 수 있습니다.</li></ol> <div class="comment-section" data-v-36cf6e80><div id="giscus-container" data-v-36cf6e80></div></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/posts/2025-08-10-scheduler-mq-data-archiving.html" class="prev">
        Scheduler와 Message Queue를 이용한 레거시 데이터 자동 아카이빙 시스템 구축
      </a></span> <span class="next"><a href="/posts/2025-07-20-ice-breaking-platform.html">
        Spring Boot와 Redis로 분산 실시간 상태 머신 구현하기
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.4c9cb557.js" defer></script><script src="/assets/js/2.f7eb169b.js" defer></script><script src="/assets/js/1.bae06eea.js" defer></script><script src="/assets/js/26.eb01e83e.js" defer></script>
  </body>
</html>
