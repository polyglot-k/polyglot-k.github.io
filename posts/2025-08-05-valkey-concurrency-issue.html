<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis Lua 스크립트를 활용한 동시성 제어와 좌석 선점 로직 개선기 | Polyglot-K의 블로그</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css">
    <meta name="description" content="다양한 도전을 즐기는 개발자 Polyglot-K의 블로그입니다.">
    
    <link rel="preload" href="/assets/css/0.styles.6efed9ee.css" as="style"><link rel="preload" href="/assets/js/app.3e0c7978.js" as="script"><link rel="preload" href="/assets/js/2.e2e96b39.js" as="script"><link rel="preload" href="/assets/js/1.49846db0.js" as="script"><link rel="preload" href="/assets/js/26.e0bcc60b.js" as="script"><link rel="prefetch" href="/assets/js/10.1e3fe773.js"><link rel="prefetch" href="/assets/js/11.56e5a865.js"><link rel="prefetch" href="/assets/js/12.1aa3b0c3.js"><link rel="prefetch" href="/assets/js/13.1dd11157.js"><link rel="prefetch" href="/assets/js/14.0122fd01.js"><link rel="prefetch" href="/assets/js/15.18ef8915.js"><link rel="prefetch" href="/assets/js/16.98147816.js"><link rel="prefetch" href="/assets/js/17.46fff286.js"><link rel="prefetch" href="/assets/js/18.a9838e2e.js"><link rel="prefetch" href="/assets/js/19.34738524.js"><link rel="prefetch" href="/assets/js/20.27ef86b3.js"><link rel="prefetch" href="/assets/js/21.c7b8d009.js"><link rel="prefetch" href="/assets/js/22.f84154f0.js"><link rel="prefetch" href="/assets/js/23.fbc1d3ff.js"><link rel="prefetch" href="/assets/js/24.c58c220f.js"><link rel="prefetch" href="/assets/js/25.8c8a0afd.js"><link rel="prefetch" href="/assets/js/27.017d7e2a.js"><link rel="prefetch" href="/assets/js/3.75064c1e.js"><link rel="prefetch" href="/assets/js/4.2afe5cdc.js"><link rel="prefetch" href="/assets/js/5.a37b361e.js"><link rel="prefetch" href="/assets/js/6.c34bda13.js"><link rel="prefetch" href="/assets/js/7.b04f2031.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.6fed1ae2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6efed9ee.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Polyglot-K의 블로그</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/posts/2025-08-25-spring-webflux-performance.html" class="nav-link">
  Posts
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/posts/2025-08-25-spring-webflux-performance.html" class="nav-link">
  Posts
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>게시물 목록</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/posts/2025-08-25-spring-webflux-performance.html" class="sidebar-link">Spring Webflux 애플리케이션 성능 병목 분석 및 38배 개선기</a></li><li><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html" class="sidebar-link">아웃박스 패턴을 통한 중간 상태 데이터 관리와 복원 가능한 배치 설계</a></li><li><a href="/posts/2025-08-05-valkey-concurrency-issue.html" aria-current="page" class="active sidebar-link">Redis Lua 스크립트를 활용한 동시성 제어와 좌석 선점 로직 개선기</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/posts/2025-08-05-valkey-concurrency-issue.html#_1️⃣-초창기-접근-select-for-update-기반의-비관적-락" class="sidebar-link">1️⃣ 초창기 접근 — SELECT FOR UPDATE 기반의 비관적 락</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-05-valkey-concurrency-issue.html#_2️⃣-redis를-활용한-선점-구조로의-전환" class="sidebar-link">2️⃣ Redis를 활용한 선점 구조로의 전환</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-05-valkey-concurrency-issue.html#_3️⃣-ttl을-통한-유효기간-관리와-캐시-스탬피드-방지" class="sidebar-link">3️⃣ TTL을 통한 유효기간 관리와 캐시 스탬피드 방지</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-05-valkey-concurrency-issue.html#_4️⃣-eventually-consistent한-redis-→-db-동기화" class="sidebar-link">4️⃣ Eventually Consistent한 Redis → DB 동기화</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-05-valkey-concurrency-issue.html#_5️⃣-트레이드오프-분석" class="sidebar-link">5️⃣ 트레이드오프 분석</a></li><li class="sidebar-sub-header"><a href="/posts/2025-08-05-valkey-concurrency-issue.html#_6️⃣-회고" class="sidebar-link">6️⃣ 회고</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/posts/2025-08-05-valkey-concurrency-issue.html#💡-배운-점-요약" class="sidebar-link">💡 배운 점 요약</a></li></ul></li></ul></li><li><a href="/posts/2025-07-20-ice-breaking-platform.html" class="sidebar-link">Redis Pub/Sub 으로 분산 실시간 상태 머신 구현하기</a></li><li><a href="/posts/2025-07-15-text-based-real-time-streaming-virtual-interview.html" class="sidebar-link">Spring WebFlux와 Redis로 구축한 LLM 스트리밍 파이프라인</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="redis-lua-스크립트를-활용한-동시성-제어와-좌석-선점-로직-개선기"><a href="#redis-lua-스크립트를-활용한-동시성-제어와-좌석-선점-로직-개선기" class="header-anchor">#</a> Redis Lua 스크립트를 활용한 동시성 제어와 좌석 선점 로직 개선기</h1> <p>모의 수능 신청 플랫폼을 개발하면서 가장 까다로웠던 부분은 <strong>좌석 선점 로직</strong>이었다.
한정된 좌석(200석)을 여러 명이 동시에 클릭해도, 중복 없이 정확하게 신청되도록 보장해야 했다.
이는 단순한 기능이 아니라, <strong>시스템 신뢰성과 사용자 경험을 좌우하는 핵심 문제</strong>였다.</p> <h2 id="_1️⃣-초창기-접근-select-for-update-기반의-비관적-락"><a href="#_1️⃣-초창기-접근-select-for-update-기반의-비관적-락" class="header-anchor">#</a> 1️⃣ 초창기 접근 — <code>SELECT FOR UPDATE</code> 기반의 비관적 락</h2> <p>초기에는 데이터베이스 수준에서 문제를 해결하기 위해 <code>SELECT FOR UPDATE</code>를 사용했다.
즉, 신청이 들어올 때마다 해당 학교의 시험 행(row)에 락을 걸고 좌석 수를 갱신하는 방식이었다.
이 구조는 정합성을 완벽하게 보장하지만, <strong>트랜잭션 구간이 길어질수록 병목이 심해진다.</strong></p> <p>당시 제휴된 학교는 총 6곳, 학교당 좌석은 200석이었다.
사전 리서치 결과, 한 학교에 400명 이상이 몰릴 가능성이 높았다.
즉, 락 경쟁이 피할 수 없는 상황이었다.</p> <p>이를 검증하기 위해 <code>Little’s Law</code>를 적용해봤다.
평균 트랜잭션 시간이 약 100ms였으므로, 한 행(row) 기준으로 초당 약 10건의 요청밖에 처리할 수 없었다.
6개 학교 기준으로 약 60TPS가 한계였다.
실제 테스트에서도 유사한 수치가 나왔고, 동시에 200명 이상이 접속하면
락 대기열이 길어지면서 응답 지연이 눈에 띄게 늘어났다.</p> <p>이 방식은 안정적이지만, <strong>처리량과 확장성 측면에서는 한계가 명확했다.</strong></p> <h2 id="_2️⃣-redis를-활용한-선점-구조로의-전환"><a href="#_2️⃣-redis를-활용한-선점-구조로의-전환" class="header-anchor">#</a> 2️⃣ Redis를 활용한 선점 구조로의 전환</h2> <p>이후 접근 방식을 완전히 바꿨다.
Redis는 기본적으로 <strong>싱글 스레드 기반의 이벤트 루프 아키텍처</strong>를 사용하기 때문에,
명령이 동시에 들어와도 내부적으로 순차적으로 처리된다.
즉, 락 없이도 <strong>명령 간 원자성(Atomicity)</strong> 을 보장할 수 있다.</p> <p>여기에 <strong>Lua 스크립트</strong>를 결합하면 여러 명령을 하나의 트랜잭션처럼 묶어 실행할 수 있다.
이 덕분에 신청 요청이 아무리 동시에 들어와도 “중간에 끼어드는 연산”이 발생하지 않는다.</p> <p>실제 평균 실행 속도는 약 0.7ms, 빠르면 0.5ms 수준이었다.
이를 기준으로 계산하면 초당 약 2000건의 요청을 안정적으로 처리할 수 있다.
즉, 기존의 60TPS 구조 대비 약 <strong>33배 향상된 성능</strong>이었다.
동시 접속자 수가 400명을 넘어도 병목이 발생하지 않았다.</p> <h2 id="_3️⃣-ttl을-통한-유효기간-관리와-캐시-스탬피드-방지"><a href="#_3️⃣-ttl을-통한-유효기간-관리와-캐시-스탬피드-방지" class="header-anchor">#</a> 3️⃣ TTL을 통한 유효기간 관리와 캐시 스탬피드 방지</h2> <p>Redis에 좌석 정보를 저장한 뒤에는,
시험 종료 시점 이후에도 일정 시간 동안은 보상 트랜잭션을 처리할 수 있어야 했다.
이를 위해 각 학교의 좌석 키에 <strong>TTL(Time To Live)</strong> 을 설정했다.
시험 종료 후 2시간까지 데이터를 유지하도록 하여,
결제 취소나 보상 로직이 정상적으로 작동할 수 있도록 했다.</p> <p>또한 TTL 만료 시점이 모두 동일할 경우,
한순간에 캐시가 동시에 삭제되는 “캐시 스탬피드(Cache Stampede)” 현상이 발생할 수 있다.
이를 방지하기 위해 TTL에 <strong>무작위 지연 값(jitter)</strong> 을 더해 만료 시점을 분산시켰다.
결과적으로 Redis가 안정적인 캐시 레이어로 동작할 수 있었다.</p> <h2 id="_4️⃣-eventually-consistent한-redis-→-db-동기화"><a href="#_4️⃣-eventually-consistent한-redis-→-db-동기화" class="header-anchor">#</a> 4️⃣ Eventually Consistent한 Redis → DB 동기화</h2> <p>Redis는 인메모리 저장소이기 때문에,
결국 MySQL과의 <strong>최종 일관성(Eventual Consistency)</strong> 을 맞춰주는 과정이 필요했다.</p> <p>이를 위해 스케줄러를 두고, <strong>30분 간격으로 Redis의 데이터를 DB와 동기화</strong>했다.
DB에서는 <code>GROUP BY</code>를 통해 학교별 신청자 수를 집계한 뒤,
이를 Redis에 다시 반영하는 식으로 “진실의 원본(Source of Truth)”을 주기적으로 복원했다.</p> <p>이 방식은 완벽한 실시간 일관성을 제공하진 않지만,
시험 신청이라는 도메인 특성상 <strong>수 초 단위의 정확성보다 처리 속도와 경험이 더 중요</strong>했다.</p> <p>단, 마감 직전에 신청만 완료되고 실제 결제나 동기화가 되지 않은 케이스가 생길 수 있었다.
이 문제는 시험 종료 이후 “좌석 보정 스케줄러”를 통해 Redis와 DB의 데이터 차이를 재조정하는 방식으로 해결했다.</p> <h2 id="_5️⃣-트레이드오프-분석"><a href="#_5️⃣-트레이드오프-분석" class="header-anchor">#</a> 5️⃣ 트레이드오프 분석</h2> <p>이 시점에서 정리해보면 다음과 같다.</p> <table><thead><tr><th>항목</th> <th>비관적 락 기반 구조</th> <th>Redis + Lua 구조</th></tr></thead> <tbody><tr><td>정합성</td> <td>강한 일관성 (Strong Consistency)</td> <td>최종적 일관성 (Eventually Consistent)</td></tr> <tr><td>처리량</td> <td>약 60 TPS</td> <td>약 2000 TPS</td></tr> <tr><td>평균 응답 시간</td> <td>100ms</td> <td>0.5~0.7ms</td></tr> <tr><td>장애 복구</td> <td>단순 (롤백)</td> <td>보상 트랜잭션 필요</td></tr> <tr><td>운영 난이도</td> <td>낮음</td> <td>중간 (TTL 관리 및 동기화 필요)</td></tr></tbody></table> <p>즉, 비관적 락은 안정적이지만 느리고,
Redis는 빠르지만 보상 로직이 필요하다.
결국 “어떤 일관성 수준을 받아들일 것인가”의 문제였다.
이번 프로젝트에서는 <strong>속도와 가용성을 우선시하는 AP 중심 설계</strong>를 택했다.</p> <h2 id="_6️⃣-회고"><a href="#_6️⃣-회고" class="header-anchor">#</a> 6️⃣ 회고</h2> <p>이 방식이 완벽하다고 말할 수는 없다.
보상 로직이 추가되면서 운영 복잡도가 늘었고,
마감 직전 동기화 타이밍에 따라 일부 좌석 불일치가 발생할 가능성도 있었다.</p> <p>하지만 제한된 시간과 리소스 안에서,
<strong>사용자 경험을 해치지 않으면서 시스템 안정성을 확보한 현실적인 선택</strong>이었다고 생각한다.</p> <p>무엇보다 이번 경험을 통해 깨달은 점은 단순하다.
“모든 시스템은 트레이드오프 위에 세워진다.”
정합성, 성능, 복구성 중 무엇을 우선시할지 명확히 정의하지 않으면
결국 어느 것도 제대로 만족시키지 못한다는 것이다.</p> <h3 id="💡-배운-점-요약"><a href="#💡-배운-점-요약" class="header-anchor">#</a> 💡 배운 점 요약</h3> <ul><li>비관적 락은 안정적이지만, 대규모 동시 요청에서는 병목이 빠르게 발생한다.</li> <li>Redis + Lua는 원자적 연산으로 높은 처리량을 확보할 수 있지만, 보상 설계가 필수적이다.</li> <li>TTL과 jitter는 캐시 스탬피드와 데이터 유실을 예방하는 강력한 도구다.</li> <li>완벽한 정합성보다는 <strong>도메인에 맞는 일관성 수준을 설계하는 것이 중요</strong>하다.</li></ul> <div class="comment-section" data-v-36cf6e80><div id="giscus-container" data-v-36cf6e80></div></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/posts/2025-08-10-scheduler-mq-data-archiving.html" class="prev">
        아웃박스 패턴을 통한 중간 상태 데이터 관리와 복원 가능한 배치 설계
      </a></span> <span class="next"><a href="/posts/2025-07-20-ice-breaking-platform.html">
        Redis Pub/Sub 으로 분산 실시간 상태 머신 구현하기
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3e0c7978.js" defer></script><script src="/assets/js/2.e2e96b39.js" defer></script><script src="/assets/js/1.49846db0.js" defer></script><script src="/assets/js/26.e0bcc60b.js" defer></script>
  </body>
</html>
