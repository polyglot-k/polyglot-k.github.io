<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Spring Boot와 Redis로 분산 실시간 상태 머신 구현하기 | Polyglot-K의 블로그</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css">
    <meta name="description" content="다양한 도전을 즐기는 개발자 Polyglot-K의 블로그입니다.">
    
    <link rel="preload" href="/assets/css/0.styles.6efed9ee.css" as="style"><link rel="preload" href="/assets/js/app.4c9cb557.js" as="script"><link rel="preload" href="/assets/js/2.f7eb169b.js" as="script"><link rel="preload" href="/assets/js/1.bae06eea.js" as="script"><link rel="preload" href="/assets/js/20.c887495e.js" as="script"><link rel="prefetch" href="/assets/js/10.a8ed9aac.js"><link rel="prefetch" href="/assets/js/11.56e5a865.js"><link rel="prefetch" href="/assets/js/12.8e76f9af.js"><link rel="prefetch" href="/assets/js/13.b66fe074.js"><link rel="prefetch" href="/assets/js/14.4cf20308.js"><link rel="prefetch" href="/assets/js/15.18ef8915.js"><link rel="prefetch" href="/assets/js/16.c2529bc5.js"><link rel="prefetch" href="/assets/js/17.46fff286.js"><link rel="prefetch" href="/assets/js/18.4ea92fd9.js"><link rel="prefetch" href="/assets/js/19.34738524.js"><link rel="prefetch" href="/assets/js/21.64a0c85e.js"><link rel="prefetch" href="/assets/js/22.aa8d2bb9.js"><link rel="prefetch" href="/assets/js/23.a05ca660.js"><link rel="prefetch" href="/assets/js/24.06019492.js"><link rel="prefetch" href="/assets/js/25.d19adc15.js"><link rel="prefetch" href="/assets/js/26.eb01e83e.js"><link rel="prefetch" href="/assets/js/27.3b05e789.js"><link rel="prefetch" href="/assets/js/3.8c9b5f96.js"><link rel="prefetch" href="/assets/js/4.d28c46f7.js"><link rel="prefetch" href="/assets/js/5.42da3f61.js"><link rel="prefetch" href="/assets/js/6.222dbcbc.js"><link rel="prefetch" href="/assets/js/7.51e9e0b3.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.663d6e13.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6efed9ee.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Polyglot-K의 블로그</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/posts/2025-08-25-spring-webflux-performance.html" class="nav-link">
  Posts
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/posts/2025-08-25-spring-webflux-performance.html" class="nav-link">
  Posts
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>게시물 목록</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/posts/2025-08-25-spring-webflux-performance.html" class="sidebar-link">Spring Webflux 애플리케이션 성능 병목 분석 및 38배 개선기</a></li><li><a href="/posts/2025-08-10-scheduler-mq-data-archiving.html" class="sidebar-link">Scheduler와 Message Queue를 이용한 레거시 데이터 자동 아카이빙 시스템 구축</a></li><li><a href="/posts/2025-08-05-valkey-concurrency-issue.html" class="sidebar-link">Valkey(Redis) Lua 스크립트를 이용한 분산 환경의 동시성 문제 해결</a></li><li><a href="/posts/2025-07-20-ice-breaking-platform.html" aria-current="page" class="active sidebar-link">Spring Boot와 Redis로 분산 실시간 상태 머신 구현하기</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/posts/2025-07-20-ice-breaking-platform.html#_1-the-challenge-분산-환경에서의-상태-불일치" class="sidebar-link">1. The Challenge: 분산 환경에서의 상태 불일치</a></li><li class="sidebar-sub-header"><a href="/posts/2025-07-20-ice-breaking-platform.html#_2-architecture-redis와-enum을-활용한-경량-상태-머신" class="sidebar-link">2. Architecture: Redis와 Enum을 활용한 경량 상태 머신</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/posts/2025-07-20-ice-breaking-platform.html#최종-동작-흐름" class="sidebar-link">최종 동작 흐름</a></li></ul></li><li class="sidebar-sub-header"><a href="/posts/2025-07-20-ice-breaking-platform.html#_3-implementation-code-level-deep-dive" class="sidebar-link">3. Implementation: Code-Level Deep Dive</a></li><li class="sidebar-sub-header"><a href="/posts/2025-07-20-ice-breaking-platform.html#_4-key-takeaways" class="sidebar-link">4. Key Takeaways</a></li></ul></li><li><a href="/posts/2025-07-15-text-based-real-time-streaming-virtual-interview.html" class="sidebar-link">[Technical Deep Dive] Spring WebFlux와 Redis로 구축한 LLM 스트리밍 파이프라인 여정기</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="spring-boot와-redis로-분산-실시간-상태-머신-구현하기"><a href="#spring-boot와-redis로-분산-실시간-상태-머신-구현하기" class="header-anchor">#</a> Spring Boot와 Redis로 분산 실시간 상태 머신 구현하기</h1> <blockquote><p>이 포스트는 멀티-인스턴스 Spring Boot 환경에서 실시간 게임 이벤트를 동기화하기 위해, Redis를 활용한 경량 분산 상태 머신을 직접 구현한 경험을 다룹니다. <code>Spring Statemachine</code> 같은 프레임워크 대신 <strong>Java Enum</strong>으로 상태 로직을, <strong>Redis</strong>로 상태 데이터를 관리하고, <strong>Redis Pub/Sub</strong>으로 상태 변경을 전파하여 아키텍처의 복잡성과 외부 의존성을 최소화한 과정을 설명합니다.</p></blockquote> <hr> <h2 id="_1-the-challenge-분산-환경에서의-상태-불일치"><a href="#_1-the-challenge-분산-환경에서의-상태-불일치" class="header-anchor">#</a> 1. The Challenge: 분산 환경에서의 상태 불일치</h2> <p><img src="/assets/img/1.92e2ac0b.png" alt="분산 시스템 아키텍처"></p> <p>실시간 아이스브레이킹 게임 플랫폼을 개발하면서, 사용자가 늘어남에 따라 서버를 멀티 인스턴스로 확장했습니다. 스케일 아웃 직후, A 인스턴스에 접속한 방장의 게임 시작 이벤트가 B 인스턴스에 있는 사용자에게 전달되지 않는 심각한 상태 불일치 문제를 겪었습니다.</p> <p><img src="/assets/img/3.20dee884.png" alt="분산 시스템 아키텍처"></p> <p>이 문제를 해결하기 위해 다음과 같은 설계 목표를 세웠습니다.</p> <ul><li><strong>단일 진실 공급원 (Single Source of Truth)</strong>: 모든 서버 인스턴스는 언제나 동일한 상태 정보를 공유해야 한다.</li> <li><strong>실시간 전파</strong>: 상태 변경은 지연 없이 모든 참여자에게 즉시 전파되어야 한다.</li> <li><strong>순서 보장 및 흐름 제어</strong>: 자동화된 서버 타이머와 사용자의 수동 커맨드가 섞여도, 이벤트는 반드시 정해진 순서대로 처리되어야 한다.</li> <li><strong>단순한 아키텍처</strong>: 새로운 기술 도입으로 인한 장애 포인트를 최소화한다.</li></ul> <h2 id="_2-architecture-redis와-enum을-활용한-경량-상태-머신"><a href="#_2-architecture-redis와-enum을-활용한-경량-상태-머신" class="header-anchor">#</a> 2. Architecture: Redis와 Enum을 활용한 경량 상태 머신</h2> <p>위 목표를 달성하기 위해 다음과 같은 기술적 결정을 내렸습니다.</p> <h4 id="상태-저장-및-전파-redis"><a href="#상태-저장-및-전파-redis" class="header-anchor">#</a> 상태 저장 및 전파: Redis</h4> <p>저희는 이미 캐싱 용도로 Redis를 사용하고 있었습니다. 따라서 외부 의존성을 추가하지 않기 위해 Redis를 두 가지 목적으로 활용했습니다.</p> <ol><li><strong>상태 저장소</strong>: 각 게임방의 현재 상태(<code>GameState</code>)를 Redis에 Key-Value 형태로 저장하여 모든 인스턴스가 공유하는 <strong>단일 진실 공급원</strong>으로 삼았습니다.</li> <li><strong>메시지 브로커</strong>: <code>RabbitMQ</code>나 <code>Kafka</code> 같은 별도의 메시지 큐 시스템을 도입하는 대신, <strong>Redis의 Pub/Sub 기능</strong>을 사용해 상태 변경 이벤트를 모든 인스턴스에 실시간으로 전파했습니다. 이를 통해 아키텍처를 단순하게 유지하고 운영 부담을 줄일 수 있었습니다.</li></ol> <h4 id="이벤트-흐름-제어-custom-enum-state-machine"><a href="#이벤트-흐름-제어-custom-enum-state-machine" class="header-anchor">#</a> 이벤트 흐름 제어: Custom Enum State Machine</h4> <p><code>Spring Statemachine</code> 같은 기존 프레임워크는 저희가 해결하려는 문제에 비해 기능이 많고 무겁다고 판단했습니다. 복잡한 설정이나 학습 비용 없이 핵심 기능에만 집중하기 위해, <strong>Java의 Enum</strong>을 사용해 상태별 로직을 캡슐화하는 가벼운 커스텀 상태 머신을 직접 구현했습니다.</p> <h3 id="최종-동작-흐름"><a href="#최종-동작-흐름" class="header-anchor">#</a> 최종 동작 흐름</h3> <p><img src="/assets/img/2.06d22194.png" alt="상태 머신 다이어그램"></p> <ol><li>이벤트가 발생하면, <strong>Redis에서 현재 상태를 조회</strong>합니다.</li> <li>커스텀 상태 머신(Enum)이 현재 상태에서 해당 이벤트를 처리할 수 있는지(<strong>Guard</strong>) 검사합니다.</li> <li>전환이 가능하다면, <strong>새로운 상태를 Redis에 저장</strong>하여 진실 공급원을 업데이트합니다.</li> <li>상태 변경 정보를 <strong>Redis Pub/Sub으로 발행(Publish)</strong> 합니다.</li> <li>모든 서버 인스턴스는 이 메시지를 구독(Subscribe)하여, 각자 담당하는 클라이언트들에게 변경된 상태를 전파합니다.</li></ol> <h2 id="_3-implementation-code-level-deep-dive"><a href="#_3-implementation-code-level-deep-dive" class="header-anchor">#</a> 3. Implementation: Code-Level Deep Dive</h2> <p>실제 구현의 핵심은 상태의 <strong>데이터(Data)</strong> 와 <strong>로직(Logic)</strong> 을 분리하는 것입니다. 상태 데이터는 Redis가, 상태 로직은 Enum이 담당합니다.</p> <p>아래는 <code>GameStateService</code>와 <code>GameState</code> Enum의 핵심 로직을 보여주는 Pesudo code 입니다.</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 각 게임 상태의 로직(Guard, Action)을 정의하는 Enum
 */</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">GameState</span> <span class="token punctuation">{</span>
    <span class="token constant">READY_TO_START</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token constant">PROFILE_VIEW</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canTransition</span><span class="token punctuation">(</span><span class="token class-name">GameContext</span> context<span class="token punctuation">,</span> <span class="token class-name">GameEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Guard: READY_TO_GAME 이벤트만 허용</span>
            <span class="token keyword">return</span> event <span class="token operator">==</span> <span class="token class-name">GameEvent</span><span class="token punctuation">.</span><span class="token constant">READY_TO_GAME</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onEnter</span><span class="token punctuation">(</span><span class="token class-name">GameContext</span> context<span class="token punctuation">,</span> <span class="token class-name">GameEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Action: 상태 진입 시 타이머 시작</span>
            context<span class="token punctuation">.</span><span class="token function">startTimer</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                context<span class="token punctuation">.</span><span class="token function">getStateMachine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handleEvent</span><span class="token punctuation">(</span><span class="token class-name">GameEvent</span><span class="token punctuation">.</span><span class="token constant">READY_TO_GAME</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// ... 다른 상태들</span>

    <span class="token comment">// 상태별 Guard, Action을 위한 추상 메서드</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canTransition</span><span class="token punctuation">(</span><span class="token class-name">GameContext</span> context<span class="token punctuation">,</span> <span class="token class-name">GameEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// 기본값: 허용</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onEnter</span><span class="token punctuation">(</span><span class="token class-name">GameContext</span> context<span class="token punctuation">,</span> <span class="token class-name">GameEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment">// 기본값: 동작 없음</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 상태 머신을 제어하고 Redis와 통신하는 서비스
 */</span>
<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GameStateService</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Autowired</span> <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">GameState</span><span class="token punctuation">&gt;</span></span> redisTemplate<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Autowired</span> <span class="token keyword">private</span> <span class="token class-name">RedisPublisher</span> redisPublisher<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleEvent</span><span class="token punctuation">(</span><span class="token class-name">GameEvent</span> event<span class="token punctuation">,</span> <span class="token class-name">GameContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> roomKey <span class="token operator">=</span> <span class="token string">&quot;room:&quot;</span> <span class="token operator">+</span> context<span class="token punctuation">.</span><span class="token function">getRoomId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 1. Redis에서 현재 상태 조회 (Source of Truth)</span>
        <span class="token class-name">GameState</span> currentState <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>roomKey<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 2. Guard: 현재 상태(Enum)의 로직으로 전환 가능 여부 확인</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>currentState<span class="token punctuation">.</span><span class="token function">canTransition</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 처리 불가 로직</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 3. 다음 상태 결정 및 Redis에 저장</span>
        <span class="token class-name">GameState</span> nextState <span class="token operator">=</span> <span class="token function">findNextState</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>roomKey<span class="token punctuation">,</span> nextState<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 4. 새로운 상태의 Action 수행</span>
        nextState<span class="token punctuation">.</span><span class="token function">onEnter</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 5. Redis Pub/Sub으로 상태 변경 전파</span>
        redisPublisher<span class="token punctuation">.</span><span class="token function">publishStateChange</span><span class="token punctuation">(</span>nextState<span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getRoomId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_4-key-takeaways"><a href="#_4-key-takeaways" class="header-anchor">#</a> 4. Key Takeaways</h2> <p>이번 경험을 통해 다음과 같은 교훈을 얻었습니다.</p> <ul><li><strong>의존성을 최소화하라</strong>: 이미 사용하는 기술(Redis)을 다목적으로 활용하면 아키텍처가 단순해지고 안정성이 높아집니다. 새로운 기술 도입은 항상 신중해야 합니다.</li> <li><strong>문제에 맞는 도구를 선택하라</strong>: 프레임워크는 강력한 도구지만, 때로는 해결하려는 문제에 비해 과할 수 있습니다. 문제의 본질을 파악하고, 필요하다면 가벼운 솔루션을 직접 만드는 것이 더 효과적일 수 있습니다.</li> <li><strong>데이터와 로직을 분리하라</strong>: 상태의 데이터(in Redis)와 상태의 행위 로직(in Enum)을 분리함으로써, 테스트가 용이하고 확장 가능한 유연한 설계를 얻을 수 있었습니다.</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/posts/2025-08-05-valkey-concurrency-issue.html" class="prev">
        Valkey(Redis) Lua 스크립트를 이용한 분산 환경의 동시성 문제 해결
      </a></span> <span class="next"><a href="/posts/2025-07-15-text-based-real-time-streaming-virtual-interview.html">
        [Technical Deep Dive] Spring WebFlux와 Redis로 구축한 LLM 스트리밍 파이프라인 여정기
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.4c9cb557.js" defer></script><script src="/assets/js/2.f7eb169b.js" defer></script><script src="/assets/js/1.bae06eea.js" defer></script><script src="/assets/js/20.c887495e.js" defer></script>
  </body>
</html>
