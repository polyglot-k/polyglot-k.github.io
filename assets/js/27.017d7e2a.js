(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{346:function(_,t,v){"use strict";v.r(t);var s=v(18),r=Object(s.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"아웃박스-패턴을-통한-중간-상태-데이터-관리와-복원-가능한-배치-설계"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#아웃박스-패턴을-통한-중간-상태-데이터-관리와-복원-가능한-배치-설계"}},[_._v("#")]),_._v(" 아웃박스 패턴을 통한 중간 상태 데이터 관리와 복원 가능한 배치 설계")]),_._v(" "),t("p",[_._v("모의 수능 신청 플랫폼을 운영하면서, “신청을 완료하지 않은 사용자”로 인해 "),t("strong",[_._v("중간 상태의 데이터가 지속적으로 남는 문제")]),_._v("를 겪었다.\n특히 결제 페이지까지 갔다가 이탈한 사용자나, 네트워크 오류로 인해 결제가 실패한 케이스에서 "),t("code",[_._v("application")]),_._v(" 테이블에 "),t("strong",[_._v("PENDING")]),_._v(" 혹은 "),t("strong",[_._v("FAILED")]),_._v(" 상태의 데이터가 그대로 잔류했다.\n이 문제는 시간이 지날수록 누적되었고, 단순히 데이터 정리 문제를 넘어 "),t("strong",[_._v("시스템 정합성")]),_._v("과 "),t("strong",[_._v("좌석 수 동기화")]),_._v("에도 영향을 주었다.")]),_._v(" "),t("h2",{attrs:{id:"_1️⃣-문제-인식-고아-orphan-데이터의-누적"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1️⃣-문제-인식-고아-orphan-데이터의-누적"}},[_._v("#")]),_._v(" 1️⃣ 문제 인식 — 고아(Orphan) 데이터의 누적")]),_._v(" "),t("p",[_._v("처음에는 단순히 “나중에 쿼리로 정리하면 되지 않을까?”라고 생각했다.\n하지만 실제 운영 환경에서는 이 문제를 무시할 수 없었다.")]),_._v(" "),t("ul",[t("li",[_._v("신청만 하고 결제하지 않은 사용자 → "),t("code",[_._v("PENDING")]),_._v(" 상태로 남음")]),_._v(" "),t("li",[_._v("결제 도중 오류가 발생한 사용자 → "),t("code",[_._v("FAILED")]),_._v(" 상태로 남음")]),_._v(" "),t("li",[_._v("이미 좌석은 Redis Lua를 통해 선점되어 있었음")])]),_._v(" "),t("p",[_._v("즉, 결제 실패나 이탈로 인해 "),t("strong",[_._v("DB는 실패 상태를 가지고 있지만 Redis에는 여전히 좌석이 점유된 상태")]),_._v("가 되는 불일치가 발생했다.\n이 불일치는 Outbox 기반의 보상 트랜잭션 설계로 해결할 수 있었다.")]),_._v(" "),t("h2",{attrs:{id:"_2️⃣-해결-방향-상태-기반-outbox-이벤트-관리"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2️⃣-해결-방향-상태-기반-outbox-이벤트-관리"}},[_._v("#")]),_._v(" 2️⃣ 해결 방향 — 상태 기반 Outbox 이벤트 관리")]),_._v(" "),t("p",[_._v("이 문제를 해결하기 위해, "),t("strong",[_._v("Outbox 패턴을 도입하여 중간 상태를 이벤트로 관리")]),_._v("하기로 했다.\n핵심 아이디어는 “상태 변경을 단순히 DB에만 반영하지 않고, Outbox에 기록하여 비동기로 후속 처리”하는 것이다.")]),_._v(" "),t("h3",{attrs:{id:"주요-설계-포인트"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#주요-설계-포인트"}},[_._v("#")]),_._v(" 주요 설계 포인트")]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("PENDING → FAILED → CLEANED")])]),_._v(" "),t("ul",[t("li",[_._v("결제 실패 시 "),t("code",[_._v("application")]),_._v(" 상태를 "),t("code",[_._v("FAILED")]),_._v("로 변경하고,\n동시에 Outbox에 “FAIL_EVENT”를 생성한다.")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("장기 PENDING 처리")])]),_._v(" "),t("ul",[t("li",[_._v("신청만 하고 일정 시간 이상 진행이 없는 경우,\n스케줄러가 "),t("code",[_._v("PENDING")]),_._v(" 데이터를 조회하여 Outbox에 “CLEAN_PENDING_EVENT”를 추가한다.")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("보상 로직 연동")])]),_._v(" "),t("ul",[t("li",[_._v("Lua 스크립트를 통해 Redis의 좌석 정보를 동기화하고,\nDB와 Redis의 상태를 일치시킨다.")])])])]),_._v(" "),t("p",[_._v("이 구조 덕분에 데이터 정리 로직이 트랜잭션 내부에 포함되지 않고,\nOutbox를 통해 안전하게 후처리될 수 있었다.")]),_._v(" "),t("h2",{attrs:{id:"_3️⃣-outbox-→-mq-흐름-설계"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3️⃣-outbox-→-mq-흐름-설계"}},[_._v("#")]),_._v(" 3️⃣ Outbox → MQ 흐름 설계")]),_._v(" "),t("p",[_._v("Outbox에 적재된 이벤트는 Poller가 주기적으로 조회하고,\n처리할 이벤트를 MQ로 전달한다.\n이때 여러 후보 중에서 "),t("strong",[_._v("RabbitMQ")]),_._v("를 선택했다.")]),_._v(" "),t("h3",{attrs:{id:"선택-이유"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#선택-이유"}},[_._v("#")]),_._v(" 선택 이유")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("DLQ(Dead Letter Queue)")]),_._v(" 기능이 내장되어 있어,\n실패한 이벤트를 따로 보관하고 운영자가 직접 모니터링 가능")]),_._v(" "),t("li",[t("strong",[_._v("Persistent Queue")]),_._v(" 설정을 통해 이벤트 유실 위험을 최소화")]),_._v(" "),t("li",[t("strong",[_._v("Batch 처리")]),_._v(" 및 "),t("strong",[_._v("재시도(backoff)")]),_._v(" 전략을 유연하게 조정 가능")])]),_._v(" "),t("p",[_._v("결국 Outbox → RabbitMQ → Listener 구조로 안정적인 이벤트 흐름이 만들어졌다.")]),_._v(" "),t("h2",{attrs:{id:"_4️⃣-batch-listener에서의-재개-resume-설계"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4️⃣-batch-listener에서의-재개-resume-설계"}},[_._v("#")]),_._v(" 4️⃣ Batch Listener에서의 재개(Resume) 설계")]),_._v(" "),t("p",[_._v("이벤트를 수신한 RabbitMQ Listener는\n관련된 "),t("code",[_._v("application")]),_._v(" 데이터를 Batch 단위로 가져와 JSON 스냅샷을 생성하고,\n이를 임시 보존 테이블에 저장한 뒤 삭제한다.")]),_._v(" "),t("p",[_._v("그러나 여기서 새로운 문제가 발생했다.\n"),t("strong",[_._v("“Batch 처리 중간에 실패하면 어디서부터 다시 시작할 것인가?”")])]),_._v(" "),t("p",[_._v("초기 구현에서는 단순히 예외 발생 시 전체 배치를 롤백시켰다.\n하지만 이 방식은 이미 처리된 데이터까지 재처리하게 되어 비효율적이었다.")]),_._v(" "),t("p",[_._v("이를 해결하기 위해, "),t("strong",[_._v("Outbox 이벤트 상태를 명시적으로 관리하는 Resume 전략")]),_._v("을 도입했다.")]),_._v(" "),t("h2",{attrs:{id:"_5️⃣-상태-기반-resume-전략-ready-→-processing-→-done"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5️⃣-상태-기반-resume-전략-ready-→-processing-→-done"}},[_._v("#")]),_._v(" 5️⃣ 상태 기반 Resume 전략 (READY → PROCESSING → DONE)")]),_._v(" "),t("p",[_._v("각 Outbox 이벤트는 세 가지 상태를 가진다.")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("상태")]),_._v(" "),t("th",[_._v("의미")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[t("strong",[_._v("READY")])]),_._v(" "),t("td",[_._v("아직 처리되지 않은 이벤트")])]),_._v(" "),t("tr",[t("td",[t("strong",[_._v("PROCESSING")])]),_._v(" "),t("td",[_._v("현재 배치 처리 중")])]),_._v(" "),t("tr",[t("td",[t("strong",[_._v("DONE")])]),_._v(" "),t("td",[_._v("성공적으로 완료된 이벤트")])])])]),_._v(" "),t("p",[_._v("배치 Listener는 Outbox에서 "),t("code",[_._v("READY")]),_._v(" 상태의 이벤트만 가져와 처리한다.\n처리 도중 예외가 발생하면 해당 이벤트는 "),t("code",[_._v("PROCESSING")]),_._v(" 상태로 남게 된다.\n이후 Poller가 다시 실행될 때,\n**“DONE이 아닌 이벤트”**부터 재개하도록 설계했다.")]),_._v(" "),t("p",[_._v("이 구조는 단순하지만 강력하다.\n시스템이 중간에 중단되더라도, Outbox의 상태 정보 덕분에\n어디서부터 다시 시작해야 하는지 명확히 알 수 있다.")]),_._v(" "),t("h2",{attrs:{id:"_6️⃣-확장-고려-단일-인스턴스-→-다중-인스턴스"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6️⃣-확장-고려-단일-인스턴스-→-다중-인스턴스"}},[_._v("#")]),_._v(" 6️⃣ 확장 고려 — 단일 인스턴스 → 다중 인스턴스")]),_._v(" "),t("p",[_._v("현재는 단일 인스턴스 기반이기 때문에,\n별도의 분산 조정 없이도 안전하게 Resume가 가능하다.\n하지만 서비스가 확장되어 여러 Consumer 인스턴스가 동작하게 되면,\n중복 처리를 방지하기 위해 "),t("strong",[_._v("분산락(distributed lock)")]),_._v(" 이 필요하다.")]),_._v(" "),t("p",[_._v("Redis 기반의 분산락 또는 RabbitMQ의 Consumer tag를 이용해\n“하나의 이벤트는 오직 하나의 Consumer만 처리하도록” 설계할 예정이다.")]),_._v(" "),t("h2",{attrs:{id:"_7️⃣-회고"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7️⃣-회고"}},[_._v("#")]),_._v(" 7️⃣ 회고")]),_._v(" "),t("p",[_._v("이 경험을 통해 배운 점은 명확하다.\n"),t("strong",[_._v("이벤트를 삭제하기보다, 상태를 명시적으로 관리하라.")])]),_._v(" "),t("p",[_._v("Outbox 패턴을 단순히 “비동기 트랜잭션 전달용”으로만 사용하면\n중간 상태 복구나 재시작(resume)이 어렵다.\n하지만 Outbox의 상태를 세분화하고, 이를 기반으로 Resume 가능한 설계를 도입하면\n예상치 못한 장애 상황에서도 데이터를 안전하게 복원할 수 있다.")]),_._v(" "),t("Comment")],1)}),[],!1,null,null,null);t.default=r.exports}}]);