(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{343:function(_,v,t){"use strict";t.r(v);var r=t(18),s=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"redis-pub-sub-으로-분산-실시간-상태-머신-구현하기"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-pub-sub-으로-분산-실시간-상태-머신-구현하기"}},[_._v("#")]),_._v(" Redis Pub/Sub 으로 분산 실시간 상태 머신 구현하기")]),_._v(" "),v("p",[_._v("이번 글에서는 사이드 프로젝트 **‘얼음땡(Icebreaker)’**을 개발하면서 겪었던,\n"),v("strong",[_._v("Redis Pub/Sub 기반의 분산 상태 관리(State Machine) 설계 경험")]),_._v("을 정리해보려 한다.\n이 프로젝트는 단순한 실시간 게임이었지만, 동시에 **“여러 인스턴스 간 상태 동기화”**라는 흥미로운 문제를 다뤘다.")]),_._v(" "),v("h2",{attrs:{id:"_1️⃣-배경-실시간-게임에서의-상태-전파-문제"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1️⃣-배경-실시간-게임에서의-상태-전파-문제"}},[_._v("#")]),_._v(" 1️⃣ 배경 — 실시간 게임에서의 상태 전파 문제")]),_._v(" "),v("p",[_._v("프로젝트의 요구사항은 명확했다.")]),_._v(" "),v("ul",[v("li",[_._v("사용자들이 하나의 방(Room)에 입장한다.")]),_._v(" "),v("li",[_._v("방장은 게임을 시작·정지할 수 있다.")]),_._v(" "),v("li",[_._v("모든 참가자에게 방 상태 변화가 "),v("strong",[_._v("실시간으로")]),_._v(" 전파되어야 한다.")])]),_._v(" "),v("p",[_._v("이때 우리는 Spring 기반의 "),v("strong",[_._v("STOMP WebSocket")]),_._v("을 사용하고 있었다.\n처음에는 "),v("code",[_._v("SimpleBroker")]),_._v(" 기반의 인메모리 브로커로 구현했지만,\n곧 한 가지 한계에 부딪혔다.")]),_._v(" "),v("blockquote",[v("p",[_._v("“서로 다른 인스턴스에 연결된 사용자들에게는 메시지가 전달되지 않는다.”")])]),_._v(" "),v("p",[_._v("즉, "),v("strong",[_._v("멀티 인스턴스 환경에서 방 상태를 브로드캐스트할 수 없는 문제")]),_._v("였다.\n우리가 사용한 구성은 다음과 같았다.")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("WAS")]),_._v(": EC2 t2.micro 인스턴스 2대")]),_._v(" "),v("li",[v("strong",[_._v("Redis")]),_._v(": EC2 t2.micro 1대")])]),_._v(" "),v("p",[_._v("MVP 단계였기 때문에 Kafka나 RabbitMQ 같은 MQ를 굳이 도입하기보다는,\n"),v("strong",[_._v("가볍고 빠른 Redis Pub/Sub")]),_._v("으로 분산 브로드캐스트를 구현해보기로 했다.")]),_._v(" "),v("h2",{attrs:{id:"_2️⃣-설계-의도-브리지-아키텍처-기반-pub-sub"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2️⃣-설계-의도-브리지-아키텍처-기반-pub-sub"}},[_._v("#")]),_._v(" 2️⃣ 설계 의도 — 브리지 아키텍처 기반 Pub/Sub")]),_._v(" "),v("p",[_._v("STOMP는 크게 두 가지 형태로 동작한다.")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("유형")]),_._v(" "),v("th",[_._v("설명")]),_._v(" "),v("th",[_._v("예시")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("strong",[_._v("SimpleBroker")])]),_._v(" "),v("td",[_._v("애플리케이션 내부 인메모리 브로커")]),_._v(" "),v("td",[_._v("단일 인스턴스용")])]),_._v(" "),v("tr",[v("td",[v("strong",[_._v("RelayBroker")])]),_._v(" "),v("td",[_._v("외부 MQ(RabbitMQ, ActiveMQ 등)와 연동")]),_._v(" "),v("td",[_._v("다중 인스턴스용")])])])]),_._v(" "),v("p",[_._v("다중 인스턴스 환경에서 "),v("code",[_._v("SimpleBroker")]),_._v("만 사용하면,\n"),v("strong",[_._v("다른 인스턴스의 세션 정보에 접근할 수 없기 때문에 메시지 전파가 불가능하다.")]),_._v("\n따라서 이를 해결하기 위해 "),v("strong",[_._v("Redis Pub/Sub 브리지 아키텍처")]),_._v("를 설계했다.")]),_._v(" "),v("ul",[v("li",[_._v("WAS 간 메시지 중계 역할을 Redis가 수행")]),_._v(" "),v("li",[_._v("각 인스턴스는 동일한 Redis 채널에 구독")]),_._v(" "),v("li",[_._v("특정 방 상태 변경 이벤트가 발생하면 Redis에 Publish")]),_._v(" "),v("li",[_._v("구독 중인 다른 인스턴스에서도 동일한 메시지를 수신 후 STOMP로 전달")])]),_._v(" "),v("p",[_._v("이 구조를 통해 "),v("strong",[_._v("멀티 인스턴스 간 브로드캐스트 문제를 간단히 해결")]),_._v("할 수 있었다.")]),_._v(" "),v("h2",{attrs:{id:"_3️⃣-문제-redis-pub-sub의-데이터-유실성"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3️⃣-문제-redis-pub-sub의-데이터-유실성"}},[_._v("#")]),_._v(" 3️⃣ 문제 — Redis Pub/Sub의 데이터 유실성")]),_._v(" "),v("p",[_._v("Redis Pub/Sub은 메시지 큐와 달리 "),v("strong",[_._v("내구성(Persistence)")]),_._v(" 이 없다.\n즉, Subscriber가 잠시 끊겨있으면 해당 기간의 메시지는 유실된다.")]),_._v(" "),v("p",[_._v("실시간 게임에서는 모든 참가자가 “현재 방의 상태”를 동일하게 인식해야 하기 때문에,\n메시지 유실은 곧 "),v("strong",[_._v("게임 동기화 실패")]),_._v("로 이어진다.")]),_._v(" "),v("p",[_._v("이를 해결하기 위해 다음과 같은 보조 구조를 설계했다.")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("Redis String")]),_._v(" 구조로 각 방의 현재 상태를 별도로 저장")]),_._v(" "),v("ul",[v("li",[_._v("예: "),v("code",[_._v('room:{roomId} → {"state": "PLAYING", "players": ["user1", "user2"]}')])])])]),_._v(" "),v("li",[v("p",[_._v("클라이언트가 방에 재입장하거나 재연결할 경우,\nRedis에서 최신 상태를 조회하여 복원하도록 구성")])])]),_._v(" "),v("p",[_._v("즉, Pub/Sub은 “변경 이벤트 전파” 용도로만 사용하고,\n"),v("strong",[_._v("실제 상태의 Source of Truth는 Redis String으로 관리")]),_._v("했다.")]),_._v(" "),v("h2",{attrs:{id:"_4️⃣-상태-전이-로직-간단한-커스텀-상태-머신"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4️⃣-상태-전이-로직-간단한-커스텀-상태-머신"}},[_._v("#")]),_._v(" 4️⃣ 상태 전이 로직 — 간단한 커스텀 상태 머신")]),_._v(" "),v("p",[_._v("방의 상태는 단순한 토글 수준이 아니라, 여러 전이 규칙을 가지고 있었다.")]),_._v(" "),v("p",[_._v("예를 들어,")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("WAITING")]),_._v(" → "),v("code",[_._v("READY")]),_._v(" → "),v("code",[_._v("PLAYING")]),_._v(" → "),v("code",[_._v("FINISHED")])]),_._v(" "),v("li",[_._v("각 단계마다 유효한 입력만 전이 가능해야 한다.")])]),_._v(" "),v("p",[_._v("초기에는 단순한 "),v("code",[_._v("if-else")]),_._v(" 분기로 전이를 관리했지만,\n상태가 늘어나자 코드 복잡도가 기하급수적으로 증가했다.")]),_._v(" "),v("p",[_._v("이때 "),v("strong",[_._v("Spring StateMachine 프레임워크")]),_._v("를 검토했다.\n하지만 러닝 커브와 오버헤드가 높았고,\nMVP 단계에서는 필요한 기능만 직접 구현하는 것이 더 효율적이었다.")]),_._v(" "),v("p",[_._v("그래서 학부 시절 배운 "),v("strong",[_._v("오토마타(Automata)")]),_._v(" 개념을 떠올려,\n아래와 같은 구조를 직접 정의했다.")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("구성 요소")]),_._v(" "),v("th",[_._v("역할")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("strong",[_._v("State")])]),_._v(" "),v("td",[_._v("방의 현재 상태 (WAITING, PLAYING 등)")])]),_._v(" "),v("tr",[v("td",[v("strong",[_._v("Transition")])]),_._v(" "),v("td",[_._v("특정 입력(Event)에 따른 상태 전이")])]),_._v(" "),v("tr",[v("td",[v("strong",[_._v("Guard")])]),_._v(" "),v("td",[_._v("전이 가능 여부 검사")])]),_._v(" "),v("tr",[v("td",[v("strong",[_._v("Action")])]),_._v(" "),v("td",[_._v("전이 시 수행되는 로직")])])])]),_._v(" "),v("p",[_._v("결국, Redis에 저장된 "),v("code",[_._v("room:{id}")]),_._v(" 상태를 읽고,\n전이 가능 여부를 확인한 뒤 새로운 상태로 업데이트하는\n"),v("strong",[_._v("경량 커스텀 상태 머신")]),_._v("을 완성했다.")]),_._v(" "),v("h2",{attrs:{id:"_5️⃣-상태-전이-→-브로드캐스트"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5️⃣-상태-전이-→-브로드캐스트"}},[_._v("#")]),_._v(" 5️⃣ 상태 전이 → 브로드캐스트")]),_._v(" "),v("p",[_._v("상태가 성공적으로 전이되면,\n해당 이벤트를 모든 참가자에게 브로드캐스트해야 했다.")]),_._v(" "),v("p",[_._v("이를 위해 내부적으로 "),v("strong",[v("code",[_._v("SimpleStompNotifier")])]),_._v(" 콜백을 두었다.\n상태 전이가 발생할 때마다\n해당 방에 속한 모든 세션에게 STOMP 메시지를 전송하는 방식이다.")]),_._v(" "),v("p",[_._v("즉, 하나의 상태 전이가 다음과 같은 흐름으로 이어졌다.")]),_._v(" "),v("ol",[v("li",[_._v("Redis에 저장된 방 상태 조회")]),_._v(" "),v("li",[_._v("상태 머신으로 전이 가능 여부 판단")]),_._v(" "),v("li",[_._v("새로운 상태 저장")]),_._v(" "),v("li",[_._v("Redis Pub/Sub으로 상태 변경 이벤트 발행")]),_._v(" "),v("li",[_._v("다른 인스턴스에서 수신 후 STOMP를 통해 클라이언트에게 전달")])]),_._v(" "),v("p",[_._v("이 과정을 통해,\n"),v("strong",[_._v("서버 인스턴스 간의 실시간 상태 동기화")]),_._v("와\n"),v("strong",[_._v("클라이언트에게의 실시간 전파")]),_._v("를 동시에 달성했다.")]),_._v(" "),v("h2",{attrs:{id:"_6️⃣-트레이드오프와-회고"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6️⃣-트레이드오프와-회고"}},[_._v("#")]),_._v(" 6️⃣ 트레이드오프와 회고")]),_._v(" "),v("p",[_._v("이 설계는 간결하고 운영 비용이 낮다는 점에서 매우 효율적이었다.\n하지만 동시에, Redis Pub/Sub 특유의 제약도 명확했다.")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("항목")]),_._v(" "),v("th",[_._v("장점")]),_._v(" "),v("th",[_._v("한계")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("strong",[_._v("구현 복잡도")])]),_._v(" "),v("td",[_._v("낮음, 빠르게 MVP 구축 가능")]),_._v(" "),v("td",[_._v("기능 확장 시 if-else 증가")])]),_._v(" "),v("tr",[v("td",[v("strong",[_._v("운영 비용")])]),_._v(" "),v("td",[_._v("MQ 불필요, Redis 단일 운영")]),_._v(" "),v("td",[_._v("Redis 장애 시 전체 메시지 유실")])]),_._v(" "),v("tr",[v("td",[v("strong",[_._v("확장성")])]),_._v(" "),v("td",[_._v("WAS 간 실시간 전파 가능")]),_._v(" "),v("td",[_._v("Subscriber 수 증가 시 부하 증가")])]),_._v(" "),v("tr",[v("td",[v("strong",[_._v("복원성")])]),_._v(" "),v("td",[_._v("Redis String으로 상태 복원 가능")]),_._v(" "),v("td",[_._v("Pub/Sub 자체는 비내구적")])])])]),_._v(" "),v("p",[_._v("특히 Pub/Sub의 “유실성”은 완전히 해결되지 않는다.\n이 문제는 추후 Redis Stream 또는 Kafka를 도입하여\n**“메시지 내구성 + 순서 보장”**을 확보하는 방식으로 개선할 예정이다.")])])}),[],!1,null,null,null);v.default=s.exports}}]);